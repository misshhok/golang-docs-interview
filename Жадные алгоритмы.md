# Жадные алгоритмы

Greedy - делаем локально оптимальный выбор на каждом шаге.

## Концепция

**Жадный подход:** выбираем лучший вариант сейчас, не думая о будущем.

```
Задача: сдача 63 рубля монетами [50, 25, 10, 5, 1]

Жадный:
1. Берём 50 → остаток 13
2. Берём 10 → остаток 3
3. Берём 1 → остаток 2
4. Берём 1 → остаток 1
5. Берём 1 → остаток 0

Итого: 5 монет ✅
```

**Не всегда работает!**

```
Монеты: [25, 10, 1], сумма 30

Жадный: 25 + 1×5 = 6 монет ❌
Оптимум: 10×3 = 3 монеты ✅

→ Нужен DP!
```

## Когда работает Greedy

1. **Greedy Choice Property** - локальный оптимум → глобальный оптимум
2. **Optimal Substructure** - оптимум включает оптимумы подзадач

**Ключ:** докажите что жадный выбор правильный!

## Классические задачи

### 1. Activity Selection

```go
type Activity struct {
    start, end int
}

// Максимум непересекающихся активностей
func activitySelection(activities []Activity) []Activity {
    // Сортировать по времени окончания
    sort.Slice(activities, func(i, j int) bool {
        return activities[i].end < activities[j].end
    })

    result := []Activity{activities[0]}
    lastEnd := activities[0].end

    for i := 1; i < len(activities); i++ {
        if activities[i].start >= lastEnd {
            result = append(result, activities[i])
            lastEnd = activities[i].end
        }
    }

    return result
}

// activities = [(1,4), (3,5), (0,6), (5,7), (8,9), (5,9)]
// result = [(1,4), (5,7), (8,9)]
```

### 2. Fractional Knapsack

```go
type Item struct {
    value  float64
    weight float64
}

func fractionalKnapsack(items []Item, capacity float64) float64 {
    // Сортировать по value/weight (убывание)
    sort.Slice(items, func(i, j int) bool {
        return items[i].value/items[i].weight > items[j].value/items[j].weight
    })

    totalValue := 0.0

    for _, item := range items {
        if capacity >= item.weight {
            // Взять весь предмет
            totalValue += item.value
            capacity -= item.weight
        } else {
            // Взять часть
            totalValue += item.value * (capacity / item.weight)
            break
        }
    }

    return totalValue
}
```

### 3. Jump Game

```go
func canJump(nums []int) bool {
    maxReach := 0

    for i := 0; i < len(nums); i++ {
        if i > maxReach {
            return false  // Не можем достичь i
        }

        maxReach = max(maxReach, i+nums[i])

        if maxReach >= len(nums)-1 {
            return true
        }
    }

    return false
}

// canJump([2,3,1,1,4]) → true
// canJump([3,2,1,0,4]) → false
```

### 4. Jump Game II (минимум прыжков)

```go
func jump(nums []int) int {
    jumps := 0
    currentEnd := 0
    farthest := 0

    for i := 0; i < len(nums)-1; i++ {
        farthest = max(farthest, i+nums[i])

        if i == currentEnd {
            jumps++
            currentEnd = farthest
        }
    }

    return jumps
}

// jump([2,3,1,1,4]) → 2 (0→1→4)
```

### 5. Gas Station

```go
func canCompleteCircuit(gas []int, cost []int) int {
    totalTank := 0
    currentTank := 0
    start := 0

    for i := 0; i < len(gas); i++ {
        totalTank += gas[i] - cost[i]
        currentTank += gas[i] - cost[i]

        // Не можем достичь i+1 от start
        if currentTank < 0 {
            start = i + 1
            currentTank = 0
        }
    }

    if totalTank < 0 {
        return -1  // Невозможно
    }

    return start
}

// gas =  [1,2,3,4,5]
// cost = [3,4,5,1,2]
// result = 3
```

### 6. Partition Labels

```go
func partitionLabels(s string) []int {
    // Последнее вхождение каждой буквы
    lastSeen := make(map[byte]int)
    for i := 0; i < len(s); i++ {
        lastSeen[s[i]] = i
    }

    result := []int{}
    start, end := 0, 0

    for i := 0; i < len(s); i++ {
        end = max(end, lastSeen[s[i]])

        if i == end {
            result = append(result, end-start+1)
            start = i + 1
        }
    }

    return result
}

// partitionLabels("ababcbacadefegdehijhklij")
// → [9,7,8] ("ababcbaca","defegde","hijhklij")
```

### 7. Meeting Rooms II

```go
type Interval struct {
    start, end int
}

// Минимум комнат для встреч
func minMeetingRooms(intervals []Interval) int {
    starts := make([]int, len(intervals))
    ends := make([]int, len(intervals))

    for i, interval := range intervals {
        starts[i] = interval.start
        ends[i] = interval.end
    }

    sort.Ints(starts)
    sort.Ints(ends)

    rooms := 0
    endIdx := 0

    for i := 0; i < len(starts); i++ {
        if starts[i] < ends[endIdx] {
            rooms++  // Нужна новая комната
        } else {
            endIdx++  // Освободилась комната
        }
    }

    return rooms
}

// intervals = [(0,30),(5,10),(15,20)]
// result = 2
```

### 8. Remove K Digits

```go
func removeKdigits(num string, k int) string {
    stack := []byte{}

    for i := 0; i < len(num); i++ {
        digit := num[i]

        // Убрать большие цифры
        for k > 0 && len(stack) > 0 && stack[len(stack)-1] > digit {
            stack = stack[:len(stack)-1]
            k--
        }

        stack = append(stack, digit)
    }

    // Убрать оставшиеся k цифр с конца
    stack = stack[:len(stack)-k]

    // Убрать ведущие нули
    start := 0
    for start < len(stack) && stack[start] == '0' {
        start++
    }

    if start == len(stack) {
        return "0"
    }

    return string(stack[start:])
}

// removeKdigits("1432219", 3) → "1219"
// removeKdigits("10200", 1) → "200"
```

### 9. Task Scheduler

```go
func leastInterval(tasks []byte, n int) int {
    freq := make([]int, 26)
    for _, task := range tasks {
        freq[task-'A']++
    }

    sort.Ints(freq)

    maxFreq := freq[25]
    idleSlots := (maxFreq - 1) * n

    for i := 24; i >= 0 && freq[i] > 0; i-- {
        idleSlots -= min(freq[i], maxFreq-1)
    }

    if idleSlots > 0 {
        return len(tasks) + idleSlots
    }

    return len(tasks)
}

// leastInterval(["A","A","A","B","B","B"], 2) → 8
// A → B → idle → A → B → idle → A → B
```

## Huffman Coding

Оптимальное сжатие данных.

```go
type HuffmanNode struct {
    char  rune
    freq  int
    left  *HuffmanNode
    right *HuffmanNode
}

type PriorityQueue []*HuffmanNode

func (pq PriorityQueue) Len() int           { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool { return pq[i].freq < pq[j].freq }
func (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }

func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.(*HuffmanNode))
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
}

func buildHuffmanTree(freq map[rune]int) *HuffmanNode {
    pq := &PriorityQueue{}
    heap.Init(pq)

    for char, f := range freq {
        heap.Push(pq, &HuffmanNode{char: char, freq: f})
    }

    for pq.Len() > 1 {
        left := heap.Pop(pq).(*HuffmanNode)
        right := heap.Pop(pq).(*HuffmanNode)

        merged := &HuffmanNode{
            freq:  left.freq + right.freq,
            left:  left,
            right: right,
        }

        heap.Push(pq, merged)
    }

    return heap.Pop(pq).(*HuffmanNode)
}
```

## Greedy vs Dynamic Programming

| Задача | Greedy | DP | Почему |
|--------|--------|----|----|
| Coin Change (стандартные) | ✅ | ✅ | Greedy работает для стандартных монет |
| Coin Change (любые) | ❌ | ✅ | Greedy может быть неоптимален |
| Fractional Knapsack | ✅ | - | Можно брать части |
| 0/1 Knapsack | ❌ | ✅ | Нужно учитывать все комбинации |
| Activity Selection | ✅ | - | Сортировка + greedy |
| Longest Increasing Subsequence | ❌ | ✅ | Нужна оптимальная подструктура |

## Сложность

Обычно O(n log n) из-за сортировки.

## Доказательство корректности

**Пример: Activity Selection**

**Утверждение:** сортировка по end time + жадный выбор → оптимум

**Доказательство (обмен):**
1. Пусть OPT - оптимальное решение
2. Если первая активность OPT != наша первая, заменим
3. Замена не ухудшит (раньше освобождается)
4. Рекурсивно для оставшихся

## Когда использовать Greedy

**✅ Используйте когда:**
- Локальный оптимум → глобальный оптимум
- Можно доказать корректность
- Есть естественная сортировка
- DP слишком медленный

**❌ Не используйте когда:**
- Нужно учитывать все комбинации
- Контрпример существует
- Не можете доказать

## Best Practices

1. ✅ Докажите корректность (или найдите контрпример)
2. ✅ Сортировка часто помогает
3. ✅ Проверьте граничные случаи
4. ✅ Сравните с DP решением
5. ❌ Не используйте "на удачу"
6. ❌ Не забывайте о доказательстве

## Связанные темы

- [[Динамическое программирование - Основы]]
- [[Сортировки - Быстрая, слиянием, пузырьком]]
- [[Heap (куча)]]
- [[Алгоритмическая сложность (Big O)]]
