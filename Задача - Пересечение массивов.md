# Задача - Пересечение массивов

Найти пересечение (intersection) двух массивов.

## Условие

Даны два массива. Найти их пересечение.

### Вариант 1: Intersection (с дубликатами)

```
Input:  nums1 = [1, 2, 2, 1], nums2 = [2, 2]
Output: [2, 2]
```

Каждый элемент в результате должен встречаться столько раз, сколько он встречается в обоих массивах.

### Вариант 2: Intersection (уникальные элементы)

```
Input:  nums1 = [1, 2, 2, 1], nums2 = [2, 2]
Output: [2]
```

Каждый элемент в результате уникален.

## Подход 1: HashMap (для варианта с дубликатами)

**Идея:** Подсчитать частоты в первом массиве, затем пройти по второму.

```go
func intersect(nums1 []int, nums2 []int) []int {
    // Подсчитать частоты в nums1
    freq := make(map[int]int)
    for _, num := range nums1 {
        freq[num]++
    }

    result := []int{}

    // Пройти по nums2
    for _, num := range nums2 {
        if freq[num] > 0 {
            result = append(result, num)
            freq[num]--  // Уменьшить счётчик
        }
    }

    return result
}
```

**Сложность:**
- Время: O(n + m)
- Память: O(min(n, m)) - для map

**Оптимизация памяти:** Выбираем для map меньший массив.

```go
func intersect(nums1 []int, nums2 []int) []int {
    // Выбрать меньший массив для map
    if len(nums1) > len(nums2) {
        return intersect(nums2, nums1)
    }

    freq := make(map[int]int)
    for _, num := range nums1 {
        freq[num]++
    }

    result := []int{}
    for _, num := range nums2 {
        if freq[num] > 0 {
            result = append(result, num)
            freq[num]--
        }
    }

    return result
}
```

## Подход 2: Сортировка + Two Pointers

**Идея:** Отсортировать оба массива, затем двигать два указателя.

```go
func intersect(nums1 []int, nums2 []int) []int {
    // Отсортировать оба массива
    sort.Ints(nums1)
    sort.Ints(nums2)

    i, j := 0, 0
    result := []int{}

    for i < len(nums1) && j < len(nums2) {
        if nums1[i] == nums2[j] {
            result = append(result, nums1[i])
            i++
            j++
        } else if nums1[i] < nums2[j] {
            i++
        } else {
            j++
        }
    }

    return result
}
```

**Сложность:**
- Время: O(n log n + m log m) - сортировка
- Память: O(1) или O(log n + log m) - зависит от алгоритма сортировки

**Когда использовать:**
- Если массивы уже отсортированы
- Если нужна O(1) дополнительная память
- Если можно изменять входные массивы

## Подход 3: Set (для уникальных элементов)

```go
func intersection(nums1 []int, nums2 []int) []int {
    set1 := make(map[int]struct{})
    for _, num := range nums1 {
        set1[num] = struct{}{}
    }

    resultSet := make(map[int]struct{})
    for _, num := range nums2 {
        if _, exists := set1[num]; exists {
            resultSet[num] = struct{}{}
        }
    }

    // Конвертировать set в slice
    result := make([]int, 0, len(resultSet))
    for num := range resultSet {
        result = append(result, num)
    }

    return result
}
```

## Визуализация Two Pointers

```
nums1 = [1, 2, 2, 3, 4]
nums2 = [2, 2, 3, 5]

После сортировки:
nums1: [1, 2, 2, 3, 4]
        ↑
        i

nums2: [2, 2, 3, 5]
        ↑
        j

Шаг 1: 1 < 2, i++
nums1: [1, 2, 2, 3, 4]
           ↑
           i
nums2: [2, 2, 3, 5]
        ↑
        j

Шаг 2: 2 == 2, добавить 2, i++, j++
result: [2]
nums1: [1, 2, 2, 3, 4]
              ↑
              i
nums2: [2, 2, 3, 5]
           ↑
           j

Шаг 3: 2 == 2, добавить 2, i++, j++
result: [2, 2]
nums1: [1, 2, 2, 3, 4]
                 ↑
                 i
nums2: [2, 2, 3, 5]
              ↑
              j

Шаг 4: 3 == 3, добавить 3, i++, j++
result: [2, 2, 3]
nums1: [1, 2, 2, 3, 4]
                    ↑
                    i
nums2: [2, 2, 3, 5]
                 ↑
                 j

Шаг 5: 4 < 5, i++
nums1: [1, 2, 2, 3, 4]
                       ↑
                     конец

Результат: [2, 2, 3]
```

## Follow-up вопросы с собеседований

### 1. Что если массивы отсортированы?

**Ответ:** Используем Two Pointers без предварительной сортировки.

```go
// O(n + m) время, O(1) память
func intersectSorted(nums1, nums2 []int) []int {
    i, j := 0, 0
    result := []int{}

    for i < len(nums1) && j < len(nums2) {
        if nums1[i] == nums2[j] {
            result = append(result, nums1[i])
            i++
            j++
        } else if nums1[i] < nums2[j] {
            i++
        } else {
            j++
        }
    }

    return result
}
```

### 2. Что если nums1 меньше nums2 в памяти, но nums2 на диске?

**Ответ:** Загружаем nums1 в память (HashMap), затем читаем nums2 с диска чанками.

```go
func intersectDiskBased(nums1 []int, nums2File *os.File) []int {
    // Загрузить nums1 в память
    freq := make(map[int]int)
    for _, num := range nums1 {
        freq[num]++
    }

    result := []int{}

    // Читать nums2 чанками с диска
    scanner := bufio.NewScanner(nums2File)
    for scanner.Scan() {
        num, _ := strconv.Atoi(scanner.Text())
        if freq[num] > 0 {
            result = append(result, num)
            freq[num]--
        }
    }

    return result
}
```

### 3. Что если оба массива огромные и не влезают в память?

**Ответ:** External merge sort → Two pointers на отсортированных файлах.

```go
func intersectExternal(file1, file2 *os.File) []int {
    // 1. External sort обоих файлов (если не отсортированы)
    // 2. Two pointers на двух файлах

    scanner1 := bufio.NewScanner(file1)
    scanner2 := bufio.NewScanner(file2)

    result := []int{}

    // Читаем первые элементы
    scanner1.Scan()
    scanner2.Scan()
    num1, _ := strconv.Atoi(scanner1.Text())
    num2, _ := strconv.Atoi(scanner2.Text())

    for {
        if num1 == num2 {
            result = append(result, num1)

            if !scanner1.Scan() || !scanner2.Scan() {
                break
            }
            num1, _ = strconv.Atoi(scanner1.Text())
            num2, _ = strconv.Atoi(scanner2.Text())

        } else if num1 < num2 {
            if !scanner1.Scan() {
                break
            }
            num1, _ = strconv.Atoi(scanner1.Text())

        } else {
            if !scanner2.Scan() {
                break
            }
            num2, _ = strconv.Atoi(scanner2.Text())
        }
    }

    return result
}
```

## Сравнение подходов

| Подход | Время | Память | Когда использовать |
|--------|-------|--------|-------------------|
| HashMap | O(n+m) | O(min(n,m)) | Массивы не отсортированы |
| Two Pointers | O(n log n + m log m) | O(1) | Можно менять массивы |
| Two Pointers (sorted) | O(n+m) | O(1) | Массивы отсортированы |
| Set | O(n+m) | O(n+m) | Нужны уникальные элементы |

## Вариация: Union (объединение)

Найти объединение двух массивов (уникальные элементы из обоих).

```go
func union(nums1 []int, nums2 []int) []int {
    set := make(map[int]struct{})

    for _, num := range nums1 {
        set[num] = struct{}{}
    }

    for _, num := range nums2 {
        set[num] = struct{}{}
    }

    result := make([]int, 0, len(set))
    for num := range set {
        result = append(result, num)
    }

    return result
}
```

## Вариация: Разность (difference)

Элементы из nums1, которых нет в nums2.

```go
func difference(nums1 []int, nums2 []int) []int {
    set2 := make(map[int]struct{})
    for _, num := range nums2 {
        set2[num] = struct{}{}
    }

    resultSet := make(map[int]struct{})
    for _, num := range nums1 {
        if _, exists := set2[num]; !exists {
            resultSet[num] = struct{}{}
        }
    }

    result := make([]int, 0, len(resultSet))
    for num := range resultSet {
        result = append(result, num)
    }

    return result
}
```

## Задачи на работу с указателями

### In-place пересечение (модификация nums1)

```go
// Модифицировать nums1 in-place, вернуть новую длину
func intersectInPlace(nums1 []int, nums2 []int) int {
    // Подсчитать частоты nums2
    freq := make(map[int]int)
    for _, num := range nums2 {
        freq[num]++
    }

    // Записывать результат в начало nums1
    writeIdx := 0

    for _, num := range nums1 {
        if freq[num] > 0 {
            nums1[writeIdx] = num
            writeIdx++
            freq[num]--
        }
    }

    return writeIdx  // Новая длина
}

// Использование
nums1 := []int{1, 2, 2, 1}
nums2 := []int{2, 2}
newLen := intersectInPlace(nums1, nums2)
result := nums1[:newLen]  // [2, 2]
```

## Ошибки и подводные камни

### Ошибка 1: Забыли уменьшить счётчик

```go
// ❌ Неправильно
func intersect(nums1 []int, nums2 []int) []int {
    freq := make(map[int]int)
    for _, num := range nums1 {
        freq[num]++
    }

    result := []int{}
    for _, num := range nums2 {
        if freq[num] > 0 {
            result = append(result, num)
            // Забыли freq[num]--
        }
    }

    return result
}

// nums1 = [1, 2], nums2 = [2, 2]
// Вернёт [2, 2] вместо [2]
```

### Ошибка 2: Использование неправильного типа map

```go
// ❌ Неэффективно
freq := make(map[int]bool)  // bool занимает 1 байт

// ✅ Правильно
freq := make(map[int]int)   // int для подсчёта
// или
set := make(map[int]struct{})  // struct{} занимает 0 байт
```

## Вопросы на собеседовании

**Яндекс:**
"Какой подход выбрать, если один массив намного меньше другого?"

**Ответ:** HashMap с меньшим массивом (O(min(n,m)) память).

---

**VK Tech:**
"Как решить задачу, если массивы на диске?"

**Ответ:** External sort + Two pointers. Или загрузить меньший в память (HashMap).

---

**Озон:**
"Можете ли вы решить in-place без дополнительной памяти?"

**Ответ:** Только если можно сортировать массивы (Two Pointers). Иначе нужна O(n) память для HashMap.

---

**T-Bank:**
"Что если нужно найти пересечение N массивов?"

**Ответ:**

```go
func intersectMultiple(arrays [][]int) []int {
    if len(arrays) == 0 {
        return []int{}
    }

    // Подсчитать частоты в первом массиве
    freq := make(map[int]int)
    for _, num := range arrays[0] {
        freq[num]++
    }

    // Для каждого следующего массива
    for i := 1; i < len(arrays); i++ {
        newFreq := make(map[int]int)

        for _, num := range arrays[i] {
            if freq[num] > 0 {
                newFreq[num]++
                if newFreq[num] < freq[num] {
                    freq[num] = newFreq[num]
                }
            }
        }

        // Обновить freq
        freq = newFreq
    }

    // Собрать результат
    result := []int{}
    for num, count := range freq {
        for i := 0; i < count; i++ {
            result = append(result, num)
        }
    }

    return result
}
```

## Тестовые случаи

```go
func main() {
    // Тест 1: Обычный случай
    nums1 := []int{1, 2, 2, 1}
    nums2 := []int{2, 2}
    fmt.Println(intersect(nums1, nums2))  // [2, 2]

    // Тест 2: Нет пересечения
    nums1 = []int{1, 2, 3}
    nums2 = []int{4, 5, 6}
    fmt.Println(intersect(nums1, nums2))  // []

    // Тест 3: Полное пересечение
    nums1 = []int{1, 2, 3}
    nums2 = []int{1, 2, 3}
    fmt.Println(intersect(nums1, nums2))  // [1, 2, 3]

    // Тест 4: Пустой массив
    nums1 = []int{}
    nums2 = []int{1, 2}
    fmt.Println(intersect(nums1, nums2))  // []

    // Тест 5: Разные размеры
    nums1 = []int{4, 9, 5}
    nums2 = []int{9, 4, 9, 8, 4}
    fmt.Println(intersect(nums1, nums2))  // [4, 9] или [9, 4]
}
```

## Best Practices

1. ✅ Выбирайте меньший массив для HashMap
2. ✅ Используйте `map[int]struct{}` для set (0 байт)
3. ✅ Two Pointers если массивы отсортированы
4. ✅ Учитывайте ограничения памяти
5. ❌ Не забывайте уменьшать счётчик в HashMap
6. ❌ Не сортируйте, если не нужно (дорого)

## Связанные темы

- [[HashMap - Реализация и особенности]]
- [[HashSet]]
- [[Два указателя (Two Pointers)]]
- [[Сортировки - Быстрая, слиянием, пузырьком]]
- [[Алгоритмическая сложность (Big O)]]
- [[Go - Карты (maps)]]
