# Алгоритмы на строках

Эффективные алгоритмы обработки и поиска в строках.

## Базовые операции в Go

```go
// Длина строки (в рунах, не байтах!)
s := "привет"
len(s)           // 12 байт
len([]rune(s))   // 6 рун ✅

// Конкатенация
s1 + s2          // O(n+m) - создаёт новую строку

// Substring
s[start:end]     // O(1) ссылка на ту же память

// Сравнение
s1 == s2         // O(n)
s1 < s2          // Лексикографическое

// Итерация
for i, ch := range s {  // ch - rune
    fmt.Println(i, ch)
}

// strings пакет
import "strings"

strings.Contains(s, substr)
strings.HasPrefix(s, prefix)
strings.HasSuffix(s, suffix)
strings.Index(s, substr)       // Первое вхождение
strings.LastIndex(s, substr)
strings.Split(s, sep)
strings.Join(arr, sep)
strings.ToLower(s)
strings.ToUpper(s)
strings.TrimSpace(s)
strings.Replace(s, old, new, n)
```

## Поиск подстроки

### Naive Algorithm

```go
func naiveSearch(text, pattern string) []int {
    n, m := len(text), len(pattern)
    result := []int{}

    for i := 0; i <= n-m; i++ {
        match := true

        for j := 0; j < m; j++ {
            if text[i+j] != pattern[j] {
                match = false
                break
            }
        }

        if match {
            result = append(result, i)
        }
    }

    return result
}

// O(n×m) worst case
```

### KMP (Knuth-Morris-Pratt)

Пропускаем повторные сравнения используя префикс-функцию.

```go
func kmpSearch(text, pattern string) []int {
    n, m := len(text), len(pattern)

    // Построить lps (longest proper prefix which is also suffix)
    lps := computeLPS(pattern)

    result := []int{}
    i, j := 0, 0

    for i < n {
        if text[i] == pattern[j] {
            i++
            j++
        }

        if j == m {
            result = append(result, i-j)
            j = lps[j-1]
        } else if i < n && text[i] != pattern[j] {
            if j != 0 {
                j = lps[j-1]  // Не начинаем с начала!
            } else {
                i++
            }
        }
    }

    return result
}

func computeLPS(pattern string) []int {
    m := len(pattern)
    lps := make([]int, m)
    length := 0
    i := 1

    for i < m {
        if pattern[i] == pattern[length] {
            length++
            lps[i] = length
            i++
        } else {
            if length != 0 {
                length = lps[length-1]
            } else {
                lps[i] = 0
                i++
            }
        }
    }

    return lps
}

// O(n + m) время
```

### Rabin-Karp (Rolling Hash)

```go
const prime = 101

func rabinKarp(text, pattern string) []int {
    n, m := len(text), len(pattern)
    result := []int{}

    if m > n {
        return result
    }

    // Вычислить хеши
    patternHash := hash(pattern)
    textHash := hash(text[:m])

    for i := 0; i <= n-m; i++ {
        if textHash == patternHash {
            // Проверить точное совпадение
            if text[i:i+m] == pattern {
                result = append(result, i)
            }
        }

        // Rolling hash
        if i < n-m {
            textHash = rollingHash(textHash, text[i], text[i+m], m)
        }
    }

    return result
}

func hash(s string) int {
    h := 0
    for i := 0; i < len(s); i++ {
        h += int(s[i]) * pow(prime, len(s)-i-1)
    }
    return h
}

func rollingHash(oldHash int, oldChar, newChar byte, m int) int {
    oldHash -= int(oldChar) * pow(prime, m-1)
    oldHash *= prime
    oldHash += int(newChar)
    return oldHash
}

func pow(base, exp int) int {
    result := 1
    for i := 0; i < exp; i++ {
        result *= base
    }
    return result
}

// O(n+m) average, O(n×m) worst
```

## Манипуляции со строками

### Reverse String

```go
func reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

// reverse("привет") → "тевирп"
```

### Is Palindrome

```go
func isPalindrome(s string) bool {
    left, right := 0, len(s)-1

    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }

    return true
}
```

### Longest Common Prefix

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]

    for i := 1; i < len(strs); i++ {
        for !strings.HasPrefix(strs[i], prefix) {
            prefix = prefix[:len(prefix)-1]
            if prefix == "" {
                return ""
            }
        }
    }

    return prefix
}

// longestCommonPrefix(["flower","flow","flight"]) → "fl"
```

### Анаграммы

```go
func isAnagram(s, t string) bool {
    if len(s) != len(t) {
        return false
    }

    count := make(map[rune]int)

    for _, ch := range s {
        count[ch]++
    }

    for _, ch := range t {
        count[ch]--
        if count[ch] < 0 {
            return false
        }
    }

    return true
}

// Группировка анаграмм
func groupAnagrams(strs []string) [][]string {
    groups := make(map[string][]string)

    for _, str := range strs {
        key := sortString(str)
        groups[key] = append(groups[key], str)
    }

    result := [][]string{}
    for _, group := range groups {
        result = append(result, group)
    }

    return result
}

func sortString(s string) string {
    runes := []rune(s)
    sort.Slice(runes, func(i, j int) bool {
        return runes[i] < runes[j]
    })
    return string(runes)
}
```

## String Builder

Для эффективной конкатенации.

```go
import "strings"

func buildString(parts []string) string {
    // ❌ Плохо: O(n²)
    result := ""
    for _, part := range parts {
        result += part  // Создаёт новую строку каждый раз
    }

    // ✅ Хорошо: O(n)
    var builder strings.Builder
    for _, part := range parts {
        builder.WriteString(part)
    }
    return builder.String()
}
```

## Регулярные выражения

```go
import "regexp"

// Компилировать один раз
pattern := regexp.MustCompile(`\d+`)

// Проверка совпадения
matched := pattern.MatchString("abc123")  // true

// Найти первое совпадение
match := pattern.FindString("abc123def456")  // "123"

// Найти все совпадения
matches := pattern.FindAllString("abc123def456", -1)  // ["123", "456"]

// Замена
result := pattern.ReplaceAllString("abc123def456", "X")  // "abcXdefX"

// Подгруппы
pattern := regexp.MustCompile(`(\w+)@(\w+)\.(\w+)`)
matches := pattern.FindStringSubmatch("user@example.com")
// ["user@example.com", "user", "example", "com"]
```

## Edit Distance (Levenshtein)

Минимум операций (insert/delete/replace) для преобразования.

```go
func minDistance(word1, word2 string) int {
    m, n := len(word1), len(word2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 0; i <= m; i++ {
        dp[i][0] = i
    }
    for j := 0; j <= n; j++ {
        dp[0][j] = j
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = 1 + min(
                    dp[i-1][j],   // Delete
                    dp[i][j-1],   // Insert
                    dp[i-1][j-1], // Replace
                )
            }
        }
    }

    return dp[m][n]
}

// minDistance("horse", "ros") → 3
```

## Longest Palindromic Substring

```go
func longestPalindrome(s string) string {
    if len(s) == 0 {
        return ""
    }

    start, maxLen := 0, 0

    for i := 0; i < len(s); i++ {
        len1 := expandAroundCenter(s, i, i)
        len2 := expandAroundCenter(s, i, i+1)

        length := max(len1, len2)

        if length > maxLen {
            maxLen = length
            start = i - (length-1)/2
        }
    }

    return s[start : start+maxLen]
}

func expandAroundCenter(s string, left, right int) int {
    for left >= 0 && right < len(s) && s[left] == s[right] {
        left--
        right++
    }

    return right - left - 1
}

// O(n²) время, O(1) память
```

## Manacher's Algorithm

Быстрейший алгоритм для поиска палиндромов O(n).

```go
func manacher(s string) string {
    // Преобразовать "abc" → "#a#b#c#"
    t := "#"
    for _, ch := range s {
        t += string(ch) + "#"
    }

    n := len(t)
    p := make([]int, n)  // p[i] = радиус палиндрома с центром i
    center, right := 0, 0

    maxLen, centerIdx := 0, 0

    for i := 0; i < n; i++ {
        mirror := 2*center - i

        if i < right {
            p[i] = min(right-i, p[mirror])
        }

        // Расширить
        for i+p[i]+1 < n && i-p[i]-1 >= 0 && t[i+p[i]+1] == t[i-p[i]-1] {
            p[i]++
        }

        // Обновить центр
        if i+p[i] > right {
            center = i
            right = i + p[i]
        }

        // Обновить максимум
        if p[i] > maxLen {
            maxLen = p[i]
            centerIdx = i
        }
    }

    start := (centerIdx - maxLen) / 2
    return s[start : start+maxLen]
}
```

## Сложность операций

| Операция | Сложность |
|----------|-----------|
| Длина | O(1) |
| Substring | O(1) создание, O(k) копирование |
| Конкатенация | O(n+m) |
| Сравнение | O(n) |
| Поиск (naive) | O(n×m) |
| Поиск (KMP) | O(n+m) |
| Поиск (Rabin-Karp) | O(n+m) average |

## Best Practices

1. ✅ strings.Builder для конкатенации
2. ✅ []rune для работы с Unicode
3. ✅ strings пакет для стандартных операций
4. ✅ KMP для множественного поиска
5. ✅ Регулярки компилируйте один раз
6. ❌ Не используйте += в цикле
7. ❌ len(s) для Unicode считает байты, не символы

## UTF-8 и руны

```go
s := "привет"

// ❌ Неправильно
for i := 0; i < len(s); i++ {
    fmt.Println(s[i])  // Печатает байты!
}

// ✅ Правильно
for i, ch := range s {
    fmt.Println(i, ch)  // ch - rune
}

// Или
runes := []rune(s)
for i, ch := range runes {
    fmt.Println(i, ch)
}
```

## Связанные темы

- [[Go - Строки и UTF-8]]
- [[Динамическое программирование - Основы]]
- [[Два указателя (Two Pointers)]]
- [[Скользящее окно (Sliding Window)]]
- [[Trie]]
