# Go - Генерация кода (go generate)

Автоматическая генерация Go кода с помощью `go generate`.

## Базовое использование

### Директива //go:generate

```go
//go:generate команда аргументы

// Пример
//go:generate stringer -type=Status
```

**Правила:**
- Должна быть в начале строки (можно пробелы)
- Выполняется из директории файла
- Не выполняется автоматически при `go build`

### Запуск

```bash
# Запустить все //go:generate в текущем пакете
go generate

# Рекурсивно во всех пакетах
go generate ./...

# В конкретном файле
go generate file.go
```

## stringer - генерация String()

```go
//go:generate stringer -type=Status

type Status int

const (
    Pending Status = iota
    Active
    Completed
    Failed
)

// stringer генерирует файл status_string.go с методом String()
```

После `go generate`:

```go
// Автоматически сгенерированный status_string.go
func (i Status) String() string {
    switch i {
    case Pending:
        return "Pending"
    case Active:
        return "Active"
    case Completed:
        return "Completed"
    case Failed:
        return "Failed"
    default:
        return fmt.Sprintf("Status(%d)", i)
    }
}
```

### Использование

```go
status := Active
fmt.Println(status) // "Active"

// JSON marshal тоже работает
data, _ := json.Marshal(status)
fmt.Println(string(data)) // "Active"
```

## mockgen - генерация моков

```go
//go:generate mockgen -source=interface.go -destination=mocks/mock_interface.go -package=mocks

type UserRepository interface {
    GetByID(id int) (*User, error)
    Create(user *User) error
    Update(user *User) error
    Delete(id int) error
}
```

Генерирует моки для тестирования:

```go
// В тестах
mock := mocks.NewMockUserRepository(ctrl)
mock.EXPECT().GetByID(1).Return(&User{ID: 1, Name: "Alice"}, nil)
```

## easyjson - быстрая JSON сериализация

```go
//go:generate easyjson -all user.go

//easyjson:json
type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}
```

Генерирует оптимизированные Marshal/Unmarshal:

```go
// В 3-4 раза быстрее стандартного encoding/json
user := User{ID: 1, Name: "Alice"}
data, _ := user.MarshalJSON()
```

## Кастомная генерация

### Простой генератор

```go
// generate_config.go
//go:generate go run generate_config.go

package main

import (
    "fmt"
    "os"
    "text/template"
)

const configTemplate = `// Code generated by go generate; DO NOT EDIT.

package config

const (
    Version = "{{.Version}}"
    BuildTime = "{{.BuildTime}}"
)
`

func main() {
    tmpl := template.Must(template.New("config").Parse(configTemplate))

    file, _ := os.Create("generated_config.go")
    defer file.Close()

    data := struct {
        Version   string
        BuildTime string
    }{
        Version:   "1.0.0",
        BuildTime: "2024-01-15",
    }

    tmpl.Execute(file, data)
    fmt.Println("Generated config")
}
```

### С переменными окружения

```go
//go:generate sh -c "echo package main; echo; echo const BuildTime = \\\"$(date)\\\" " > buildtime.go
```

## Популярные инструменты

### 1. stringer

```bash
go install golang.org/x/tools/cmd/stringer@latest

//go:generate stringer -type=MyEnum
```

### 2. mockgen (gomock)

```bash
go install github.com/golang/mock/mockgen@latest

//go:generate mockgen -source=interface.go -destination=mock.go
```

### 3. easyjson

```bash
go install github.com/mailru/easyjson/...@latest

//go:generate easyjson -all file.go
```

### 4. protoc (protobuf)

```bash
//go:generate protoc --go_out=. --go_opt=paths=source_relative *.proto
```

### 5. sqlc (SQL -> Go)

```bash
//go:generate sqlc generate
```

### 6. oapi-codegen (OpenAPI -> Go)

```bash
go install github.com/oapi-codegen/oapi-codegen/v2/cmd/oapi-codegen@latest

//go:generate oapi-codegen -config oapi-config.yaml api/openapi.yaml
```

---

## OpenAPI - генерация сервера и клиента

Один из самых полезных кейсов `go:generate` — генерация Go-кода из OpenAPI (Swagger) спецификации. Это позволяет:

- Писать API-first: сначала спецификация, потом код
- Автоматически генерировать типы, хендлеры и клиенты
- Держать документацию и код в синхронизации

### Инструменты для OpenAPI

| Инструмент | Описание |
|------------|----------|
| **oapi-codegen** | Самый популярный, поддерживает Chi, Gin, Echo, Fiber |
| **go-swagger** | Swagger 2.0, генерирует много кода |
| **ogen** | Новый, быстрый, строгая типизация |

### Пример OpenAPI спецификации

См. пример файла: [[examples/openapi.yaml.md|openapi.yaml]] (полная спецификация с аутентификацией, пагинацией, валидацией)

```yaml
openapi: "3.0.3"
info:
  title: User API
  version: "1.0.0"
paths:
  /users:
    get:
      operationId: listUsers
      responses:
        "200":
          description: List of users
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: "#/components/schemas/User"
    post:
      operationId: createUser
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/CreateUserRequest"
      responses:
        "201":
          description: Created user
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/User"
  /users/{id}:
    get:
      operationId: getUser
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
            format: int64
      responses:
        "200":
          description: User found
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/User"
        "404":
          description: User not found
components:
  schemas:
    User:
      type: object
      required: [id, email, name]
      properties:
        id:
          type: integer
          format: int64
        email:
          type: string
          format: email
        name:
          type: string
    CreateUserRequest:
      type: object
      required: [email, name]
      properties:
        email:
          type: string
          format: email
        name:
          type: string
```

### oapi-codegen - настройка

#### Конфигурационный файл

```yaml
# oapi-config.yaml
package: api
output: internal/api/api.gen.go
generate:
  models: true           # Генерировать структуры
  chi-server: true       # Генерировать Chi сервер
  strict-server: true    # Строгие хендлеры (рекомендуется)
  embedded-spec: true    # Встроить спецификацию
```

#### Директива go:generate

```go
// internal/api/generate.go
package api

//go:generate oapi-codegen -config ../../oapi-config.yaml ../../api/openapi.yaml
```

### Сгенерированный код

После `go generate` получаем:

```go
// internal/api/api.gen.go (сгенерированный)

// Типы из схемы
type User struct {
    Id    int64  `json:"id"`
    Email string `json:"email"`
    Name  string `json:"name"`
}

type CreateUserRequest struct {
    Email string `json:"email"`
    Name  string `json:"name"`
}

// Интерфейс сервера (strict-server)
type StrictServerInterface interface {
    // GET /users
    ListUsers(ctx context.Context, request ListUsersRequestObject) (ListUsersResponseObject, error)
    // POST /users
    CreateUser(ctx context.Context, request CreateUserRequestObject) (CreateUserResponseObject, error)
    // GET /users/{id}
    GetUser(ctx context.Context, request GetUserRequestObject) (GetUserResponseObject, error)
}

// Response типы
type ListUsers200JSONResponse []User
type CreateUser201JSONResponse User
type GetUser200JSONResponse User
type GetUser404Response struct{}
```

### Реализация сервера

```go
// internal/api/server.go
package api

import (
    "context"
)

// Реализуем сгенерированный интерфейс
type Server struct {
    userRepo UserRepository
}

func NewServer(userRepo UserRepository) *Server {
    return &Server{userRepo: userRepo}
}

// ListUsers implements StrictServerInterface
func (s *Server) ListUsers(ctx context.Context, req ListUsersRequestObject) (ListUsersResponseObject, error) {
    users, err := s.userRepo.GetAll(ctx)
    if err != nil {
        return nil, err
    }
    return ListUsers200JSONResponse(users), nil
}

// CreateUser implements StrictServerInterface
func (s *Server) CreateUser(ctx context.Context, req CreateUserRequestObject) (CreateUserResponseObject, error) {
    user, err := s.userRepo.Create(ctx, req.Body.Email, req.Body.Name)
    if err != nil {
        return nil, err
    }
    return CreateUser201JSONResponse(*user), nil
}

// GetUser implements StrictServerInterface
func (s *Server) GetUser(ctx context.Context, req GetUserRequestObject) (GetUserResponseObject, error) {
    user, err := s.userRepo.GetByID(ctx, req.Id)
    if err != nil {
        return GetUser404Response{}, nil
    }
    return GetUser200JSONResponse(*user), nil
}
```

### Подключение к роутеру

```go
// cmd/server/main.go
package main

import (
    "log"
    "net/http"

    "github.com/go-chi/chi/v5"
    "myapp/internal/api"
)

func main() {
    // Создаём сервер с зависимостями
    server := api.NewServer(userRepo)

    // Оборачиваем в strict handler
    strictHandler := api.NewStrictHandler(server, nil)

    // Создаём Chi роутер
    r := chi.NewRouter()

    // Регистрируем сгенерированные маршруты
    api.HandlerFromMux(strictHandler, r)

    log.Println("Server starting on :8080")
    http.ListenAndServe(":8080", r)
}
```

### Генерация клиента

```yaml
# oapi-client-config.yaml
package: client
output: internal/client/client.gen.go
generate:
  models: true
  client: true    # Генерировать HTTP клиент
```

```go
//go:generate oapi-codegen -config ../../oapi-client-config.yaml ../../api/openapi.yaml
```

#### Использование клиента

```go
package main

import (
    "context"
    "fmt"
    "myapp/internal/client"
)

func main() {
    // Создаём клиент
    c, err := client.NewClient("http://localhost:8080")
    if err != nil {
        panic(err)
    }

    // Получаем список пользователей
    resp, err := c.ListUsers(context.Background())
    if err != nil {
        panic(err)
    }

    users, err := client.ParseListUsersResponse(resp)
    if err != nil {
        panic(err)
    }

    for _, user := range *users.JSON200 {
        fmt.Printf("User: %s (%s)\n", user.Name, user.Email)
    }
}
```

### Структура проекта с OpenAPI

```
myproject/
├── api/
│   └── openapi.yaml          # Спецификация API
├── oapi-config.yaml          # Конфиг для сервера
├── oapi-client-config.yaml   # Конфиг для клиента
├── internal/
│   ├── api/
│   │   ├── generate.go       # //go:generate директива
│   │   ├── api.gen.go        # Сгенерированный код
│   │   └── server.go         # Реализация интерфейса
│   └── client/
│       ├── generate.go
│       └── client.gen.go     # Сгенерированный клиент
├── cmd/
│   └── server/
│       └── main.go
└── Makefile
```

### Makefile для генерации

```makefile
.PHONY: generate
generate:
	go generate ./...

.PHONY: validate-openapi
validate-openapi:
	npx @redocly/cli lint api/openapi.yaml

.PHONY: docs
docs:
	npx @redocly/cli build-docs api/openapi.yaml -o docs/index.html
```

### Альтернатива: ogen

Более новый генератор с лучшей типизацией:

```bash
go install github.com/ogen-go/ogen/cmd/ogen@latest
```

```go
//go:generate ogen -target internal/api -package api api/openapi.yaml
```

**Преимущества ogen:**
- Строгая типизация (нет `interface{}`)
- Быстрее в runtime
- Лучше обрабатывает сложные схемы
- Поддержка oneOf, anyOf, allOf

### Типичные ошибки

```go
// ❌ Неправильно: редактировать сгенерированный файл
// api.gen.go - не трогать!

// ✅ Правильно: расширять через отдельные файлы
// server.go - тут ваш код
```

```yaml
# ❌ Неправильно: не указывать required поля
User:
  properties:
    id:
      type: integer

# ✅ Правильно: явно указывать required
User:
  required: [id, email]
  properties:
    id:
      type: integer
    email:
      type: string
```

---

## text/template для генерации

```go
package main

import (
    "os"
    "text/template"
)

const crudTemplate = `// Code generated; DO NOT EDIT.

package {{.Package}}

type {{.Type}}Repository struct {
    db *sql.DB
}

func (r *{{.Type}}Repository) GetByID(id int) (*{{.Type}}, error) {
    var item {{.Type}}
    err := r.db.QueryRow("SELECT * FROM {{.Table}} WHERE id = $1", id).Scan(&item)
    return &item, err
}

func (r *{{.Type}}Repository) Create(item *{{.Type}}) error {
    _, err := r.db.Exec("INSERT INTO {{.Table}} ...")
    return err
}
`

func main() {
    tmpl := template.Must(template.New("crud").Parse(crudTemplate))

    file, _ := os.Create("user_repository.go")
    defer file.Close()

    data := struct {
        Package string
        Type    string
        Table   string
    }{
        Package: "repository",
        Type:    "User",
        Table:   "users",
    }

    tmpl.Execute(file, data)
}
```

## go:embed с go:generate

```go
package main

import _ "embed"

//go:generate sh -c "git rev-parse HEAD > version.txt"
//go:embed version.txt
var gitCommit string

func main() {
    println("Git commit:", gitCommit)
}
```

## Makefile + go generate

```makefile
.PHONY: generate
generate:
	go generate ./...
	go fmt ./...

.PHONY: build
build: generate
	go build -o app ./cmd/app
```

## Best Practices

1. ✅ Добавьте сгенерированные файлы в .gitignore или коммитьте их
2. ✅ Используйте `// Code generated ... DO NOT EDIT.` в начале файла
3. ✅ Документируйте какие команды нужны (в README)
4. ✅ Запускайте `go generate` в CI/CD
5. ✅ Используйте `-v` для verbose output: `go generate -v`
6. ✅ Проверяйте что сгенерированный код компилируется
7. ❌ Не редактируйте сгенерированные файлы вручную
8. ❌ Не забывайте запускать перед коммитом

## Структура проекта

```
myproject/
├── main.go
├── types.go              // //go:generate здесь
├── types_string.go       // Сгенерированный
├── mocks/
│   └── mock_repo.go      // Сгенерированный
├── internal/
│   └── generated/
│       └── config.go     // Сгенерированный
└── tools.go              // Для управления зависимостями
```

### tools.go для зависимостей

```go
//go:build tools

package tools

import (
    _ "github.com/golang/mock/mockgen"
    _ "golang.org/x/tools/cmd/stringer"
)
```

```bash
# Установить все инструменты
go install $(go list -f '{{join .Imports " "}}' tools.go)
```

## CI/CD Integration

```yaml
# GitHub Actions
- name: Generate code
  run: go generate ./...

- name: Check for changes
  run: |
    git diff --exit-code || (echo "Generated code is out of date" && exit 1)
```

## Примеры использования

### Enum с методами

```go
//go:generate stringer -type=Color
//go:generate enumer -type=Color -json -text -yaml

type Color int

const (
    Red Color = iota
    Green
    Blue
)
```

### Mock для тестов

```go
//go:generate mockgen -source=$GOFILE -destination=mocks/mock_$GOFILE -package=mocks

type UserService interface {
    GetUser(id int) (*User, error)
    CreateUser(user *User) error
}
```

### SQL queries -> Go

```sql
-- queries.sql
-- name: GetUser :one
SELECT * FROM users WHERE id = $1;

-- name: ListUsers :many
SELECT * FROM users;
```

```go
//go:generate sqlc generate
```

## Отладка

```bash
# Verbose output
go generate -v ./...

# Запуск конкретной директивы
go generate -run stringer ./...

# Dry run (показать команды без выполнения)
go generate -n ./...

# С переменной окружения
GOARCH=amd64 go generate ./...
```

## Связанные темы

- [[Go - Основы синтаксиса]]
- [[Go - Интерфейсы]]
- [[Go - Unit тестирование]]
