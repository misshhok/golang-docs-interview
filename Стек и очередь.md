# Стек и очередь

Линейные структуры данных с ограниченным доступом к элементам.

## Стек (Stack)

**LIFO** - Last In, First Out (последним пришел - первым ушел)

### Операции

- **Push** - добавить элемент на вершину
- **Pop** - удалить элемент с вершины
- **Peek/Top** - посмотреть верхний элемент
- **IsEmpty** - проверка на пустоту
- **Size** - количество элементов

### Реализация на slice

```go
type Stack struct {
    items []int
}

func NewStack() *Stack {
    return &Stack{items: []int{}}
}

func (s *Stack) Push(item int) {
    s.items = append(s.items, item)
}

func (s *Stack) Pop() (int, error) {
    if s.IsEmpty() {
        return 0, errors.New("stack is empty")
    }
    index := len(s.items) - 1
    item := s.items[index]
    s.items = s.items[:index]
    return item, nil
}

func (s *Stack) Peek() (int, error) {
    if s.IsEmpty() {
        return 0, errors.New("stack is empty")
    }
    return s.items[len(s.items)-1], nil
}

func (s *Stack) IsEmpty() bool {
    return len(s.items) == 0
}

func (s *Stack) Size() int {
    return len(s.items)
}
```

### Сложность операций

| Операция | Сложность |
|----------|-----------|
| Push | O(1)* |
| Pop | O(1) |
| Peek | O(1) |
| IsEmpty | O(1) |

\* Амортизированное для динамического массива

### Применение стека

**1. Проверка скобок:**
```go
func isValid(s string) bool {
    stack := NewStack()
    pairs := map[rune]rune{')': '(', '}': '{', ']': '['}

    for _, ch := range s {
        if ch == '(' || ch == '{' || ch == '[' {
            stack.Push(int(ch))
        } else {
            if stack.IsEmpty() {
                return false
            }
            top, _ := stack.Pop()
            if rune(top) != pairs[ch] {
                return false
            }
        }
    }

    return stack.IsEmpty()
}

// isValid("()[]{}") → true
// isValid("([)]") → false
```

**2. Обратная польская нотация (RPN):**
```go
func evalRPN(tokens []string) int {
    stack := NewStack()

    for _, token := range tokens {
        if isOperator(token) {
            b, _ := stack.Pop()
            a, _ := stack.Pop()
            result := calculate(a, b, token)
            stack.Push(result)
        } else {
            num, _ := strconv.Atoi(token)
            stack.Push(num)
        }
    }

    result, _ := stack.Peek()
    return result
}

// evalRPN(["2", "1", "+", "3", "*"]) → 9  // (2 + 1) * 3
```

**3. Обход дерева без рекурсии:**
```go
func inorderTraversal(root *TreeNode) []int {
    result := []int{}
    stack := []*TreeNode{}
    current := root

    for current != nil || len(stack) > 0 {
        // Идем влево до конца
        for current != nil {
            stack = append(stack, current)
            current = current.Left
        }

        // Обрабатываем узел
        current = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, current.Val)

        // Идем вправо
        current = current.Right
    }

    return result
}
```

**4. History/Undo:**
```go
type TextEditor struct {
    text  string
    history []string
}

func (te *TextEditor) Type(text string) {
    te.history = append(te.history, te.text)
    te.text += text
}

func (te *TextEditor) Undo() {
    if len(te.history) > 0 {
        te.text = te.history[len(te.history)-1]
        te.history = te.history[:len(te.history)-1]
    }
}
```

## Очередь (Queue)

**FIFO** - First In, First Out (первым пришел - первым ушел)

### Операции

- **Enqueue** - добавить элемент в конец
- **Dequeue** - удалить элемент из начала
- **Front** - посмотреть первый элемент
- **IsEmpty** - проверка на пустоту
- **Size** - количество элементов

### Реализация на slice (простая)

```go
type Queue struct {
    items []int
}

func NewQueue() *Queue {
    return &Queue{items: []int{}}
}

func (q *Queue) Enqueue(item int) {
    q.items = append(q.items, item)
}

func (q *Queue) Dequeue() (int, error) {
    if q.IsEmpty() {
        return 0, errors.New("queue is empty")
    }
    item := q.items[0]
    q.items = q.items[1:]  // ⚠️ O(n) операция!
    return item, nil
}

func (q *Queue) Front() (int, error) {
    if q.IsEmpty() {
        return 0, errors.New("queue is empty")
    }
    return q.items[0], nil
}

func (q *Queue) IsEmpty() bool {
    return len(q.items) == 0
}

func (q *Queue) Size() int {
    return len(q.items)
}
```

**⚠️ Проблема:** Dequeue работает за O(n) из-за сдвига элементов.

### Реализация с двумя индексами (эффективная)

```go
type Queue struct {
    items []int
    front int
    back  int
}

func NewQueue() *Queue {
    return &Queue{
        items: make([]int, 0),
        front: 0,
        back:  0,
    }
}

func (q *Queue) Enqueue(item int) {
    q.items = append(q.items, item)
    q.back++
}

func (q *Queue) Dequeue() (int, error) {
    if q.IsEmpty() {
        return 0, errors.New("queue is empty")
    }
    item := q.items[q.front]
    q.front++

    // Периодически очищаем использованное пространство
    if q.front > len(q.items)/2 {
        q.items = q.items[q.front:q.back]
        q.back -= q.front
        q.front = 0
    }

    return item, nil
}

func (q *Queue) Front() (int, error) {
    if q.IsEmpty() {
        return 0, errors.New("queue is empty")
    }
    return q.items[q.front], nil
}

func (q *Queue) IsEmpty() bool {
    return q.front == q.back
}

func (q *Queue) Size() int {
    return q.back - q.front
}
```

### Реализация на связном списке

```go
type Node struct {
    Value int
    Next  *Node
}

type Queue struct {
    front *Node
    back  *Node
    size  int
}

func NewQueue() *Queue {
    return &Queue{}
}

func (q *Queue) Enqueue(item int) {
    newNode := &Node{Value: item}
    if q.back == nil {
        q.front = newNode
        q.back = newNode
    } else {
        q.back.Next = newNode
        q.back = newNode
    }
    q.size++
}

func (q *Queue) Dequeue() (int, error) {
    if q.IsEmpty() {
        return 0, errors.New("queue is empty")
    }
    item := q.front.Value
    q.front = q.front.Next
    if q.front == nil {
        q.back = nil
    }
    q.size--
    return item, nil
}

func (q *Queue) Front() (int, error) {
    if q.IsEmpty() {
        return 0, errors.New("queue is empty")
    }
    return q.front.Value, nil
}

func (q *Queue) IsEmpty() bool {
    return q.front == nil
}

func (q *Queue) Size() int {
    return q.size
}
```

### Сложность операций

| Операция | Slice (простая) | Slice (оптимизированная) | Linked List |
|----------|-----------------|--------------------------|-------------|
| Enqueue | O(1)* | O(1)* | O(1) |
| Dequeue | O(n) | O(1)* | O(1) |
| Front | O(1) | O(1) | O(1) |

\* Амортизированное

### Применение очереди

**1. BFS (поиск в ширину):**
```go
func bfs(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }

    result := []int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]

        result = append(result, node.Val)

        if node.Left != nil {
            queue = append(queue, node.Left)
        }
        if node.Right != nil {
            queue = append(queue, node.Right)
        }
    }

    return result
}
```

**2. Очередь задач:**
```go
type TaskQueue struct {
    tasks chan func()
}

func NewTaskQueue(workers int) *TaskQueue {
    tq := &TaskQueue{
        tasks: make(chan func(), 100),
    }

    // Запуск workers
    for i := 0; i < workers; i++ {
        go tq.worker()
    }

    return tq
}

func (tq *TaskQueue) worker() {
    for task := range tq.tasks {
        task()
    }
}

func (tq *TaskQueue) Submit(task func()) {
    tq.tasks <- task
}
```

**3. Скользящее окно:**
```go
func maxSlidingWindow(nums []int, k int) []int {
    result := []int{}
    deque := []int{}  // Индексы

    for i := 0; i < len(nums); i++ {
        // Удалить элементы вне окна
        if len(deque) > 0 && deque[0] < i-k+1 {
            deque = deque[1:]
        }

        // Удалить меньшие элементы
        for len(deque) > 0 && nums[deque[len(deque)-1]] < nums[i] {
            deque = deque[:len(deque)-1]
        }

        deque = append(deque, i)

        // Добавить максимум в результат
        if i >= k-1 {
            result = append(result, nums[deque[0]])
        }
    }

    return result
}
```

## Deque (Double-ended Queue)

Двусторонняя очередь - можно добавлять/удалять с обоих концов.

```go
type Deque struct {
    items []int
}

func (d *Deque) PushFront(item int) {
    d.items = append([]int{item}, d.items...)
}

func (d *Deque) PushBack(item int) {
    d.items = append(d.items, item)
}

func (d *Deque) PopFront() (int, error) {
    if len(d.items) == 0 {
        return 0, errors.New("deque is empty")
    }
    item := d.items[0]
    d.items = d.items[1:]
    return item, nil
}

func (d *Deque) PopBack() (int, error) {
    if len(d.items) == 0 {
        return 0, errors.New("deque is empty")
    }
    item := d.items[len(d.items)-1]
    d.items = d.items[:len(d.items)-1]
    return item, nil
}
```

## Priority Queue (Приоритетная очередь)

Элементы извлекаются в порядке приоритета, а не FIFO.

```go
import "container/heap"

type PriorityQueue []int

func (pq PriorityQueue) Len() int           { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool { return pq[i] < pq[j] }
func (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }

func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.(int))
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
}

// Использование
pq := &PriorityQueue{}
heap.Init(pq)
heap.Push(pq, 3)
heap.Push(pq, 1)
heap.Push(pq, 2)
fmt.Println(heap.Pop(pq))  // 1 (минимум)
```

Подробнее: [[Heap (куча)]]

## Монотонная очередь

Очередь где элементы всегда в возрастающем или убывающем порядке.

```go
// Монотонно убывающая очередь
type MonotonicQueue struct {
    deque []int
}

func (mq *MonotonicQueue) Push(val int) {
    // Удалить все меньшие элементы
    for len(mq.deque) > 0 && mq.deque[len(mq.deque)-1] < val {
        mq.deque = mq.deque[:len(mq.deque)-1]
    }
    mq.deque = append(mq.deque, val)
}

func (mq *MonotonicQueue) Pop(val int) {
    if len(mq.deque) > 0 && mq.deque[0] == val {
        mq.deque = mq.deque[1:]
    }
}

func (mq *MonotonicQueue) Max() int {
    return mq.deque[0]  // Максимум всегда в начале
}
```

## Стек vs Очередь

| Свойство | Стек | Очередь |
|----------|------|---------|
| Порядок | LIFO | FIFO |
| Применение | DFS, рекурсия, undo | BFS, задачи, буферизация |
| Операции | Push/Pop | Enqueue/Dequeue |

## Best Practices

1. ✅ Используйте slice для простых случаев
2. ✅ Связный список для частых удалений
3. ✅ container/list для deque
4. ✅ container/heap для priority queue
5. ✅ Channels в Go для concurrent queues
6. ❌ Не используйте slice с `items[1:]` для производительных queues

## Связанные темы

- [[Связные списки]]
- [[Heap (куча)]]
- [[BFS и DFS]]
- [[Скользящее окно (Sliding Window)]]
- [[Go - Каналы (channels)]]
