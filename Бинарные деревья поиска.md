# Бинарные деревья поиска

BST (Binary Search Tree) - бинарное дерево, где для каждого узла:
- Все узлы в левом поддереве < узел
- Все узлы в правом поддереве > узел

## Свойство BST

```
      5
     / \
    3   7
   / \ / \
  2  4 6  8

Левые < Корень < Правые
```

**In-order обход BST даёт отсортированный порядок:** 2, 3, 4, 5, 6, 7, 8

## Структура

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

type BST struct {
    Root *TreeNode
}

func NewBST() *BST {
    return &BST{}
}
```

## Операции

### Поиск

```go
func (bst *BST) Search(val int) *TreeNode {
    return search(bst.Root, val)
}

func search(node *TreeNode, val int) *TreeNode {
    if node == nil || node.Val == val {
        return node
    }

    if val < node.Val {
        return search(node.Left, val)
    }

    return search(node.Right, val)
}

// Итеративно
func searchIterative(node *TreeNode, val int) *TreeNode {
    current := node

    for current != nil {
        if val == current.Val {
            return current
        }

        if val < current.Val {
            current = current.Left
        } else {
            current = current.Right
        }
    }

    return nil
}
```

**Сложность:** O(h), где h - высота дерева
- Сбалансированное: O(log n)
- Несбалансированное: O(n)

### Вставка

```go
func (bst *BST) Insert(val int) {
    bst.Root = insert(bst.Root, val)
}

func insert(node *TreeNode, val int) *TreeNode {
    if node == nil {
        return &TreeNode{Val: val}
    }

    if val < node.Val {
        node.Left = insert(node.Left, val)
    } else if val > node.Val {
        node.Right = insert(node.Right, val)
    }
    // Если val == node.Val, дубликаты не вставляем

    return node
}

// Итеративно
func (bst *BST) InsertIterative(val int) {
    newNode := &TreeNode{Val: val}

    if bst.Root == nil {
        bst.Root = newNode
        return
    }

    current := bst.Root
    for {
        if val < current.Val {
            if current.Left == nil {
                current.Left = newNode
                return
            }
            current = current.Left
        } else {
            if current.Right == nil {
                current.Right = newNode
                return
            }
            current = current.Right
        }
    }
}
```

**Пример:**

```go
bst := NewBST()
bst.Insert(5)
bst.Insert(3)
bst.Insert(7)
bst.Insert(2)
bst.Insert(4)

//      5
//     / \
//    3   7
//   / \
//  2   4
```

### Удаление

**3 случая:**

1. **Узел - лист** → просто удалить
2. **Узел имеет одного ребёнка** → заменить узел на ребёнка
3. **Узел имеет двух детей** → заменить на inorder successor (или predecessor)

```go
func (bst *BST) Delete(val int) {
    bst.Root = deleteNode(bst.Root, val)
}

func deleteNode(node *TreeNode, val int) *TreeNode {
    if node == nil {
        return nil
    }

    if val < node.Val {
        node.Left = deleteNode(node.Left, val)
    } else if val > node.Val {
        node.Right = deleteNode(node.Right, val)
    } else {
        // Нашли узел для удаления

        // Случай 1 и 2: 0 или 1 ребёнок
        if node.Left == nil {
            return node.Right
        }
        if node.Right == nil {
            return node.Left
        }

        // Случай 3: 2 ребёнка
        // Найти inorder successor (минимум в правом поддереве)
        successor := findMin(node.Right)
        node.Val = successor.Val
        node.Right = deleteNode(node.Right, successor.Val)
    }

    return node
}

func findMin(node *TreeNode) *TreeNode {
    for node.Left != nil {
        node = node.Left
    }
    return node
}

func findMax(node *TreeNode) *TreeNode {
    for node.Right != nil {
        node = node.Right
    }
    return node
}
```

**Пример удаления узла с двумя детьми:**

```
Удалить 5:

      5              6
     / \            / \
    3   7    →     3   7
   / \ / \        / \   \
  2  4 6  8      2  4    8

Inorder successor = 6 (минимум в правом поддереве)
```

## Проверка валидности BST

```go
func isValidBST(root *TreeNode) bool {
    return validate(root, nil, nil)
}

func validate(node *TreeNode, min, max *int) bool {
    if node == nil {
        return true
    }

    // Проверка границ
    if min != nil && node.Val <= *min {
        return false
    }
    if max != nil && node.Val >= *max {
        return false
    }

    // Рекурсивная проверка
    return validate(node.Left, min, &node.Val) &&
        validate(node.Right, &node.Val, max)
}
```

**Альтернативный подход через inorder:**

```go
func isValidBST2(root *TreeNode) bool {
    values := []int{}
    inorder(root, &values)

    // Проверить, что массив отсортирован
    for i := 1; i < len(values); i++ {
        if values[i] <= values[i-1] {
            return false
        }
    }

    return true
}

func inorder(node *TreeNode, values *[]int) {
    if node == nil {
        return
    }

    inorder(node.Left, values)
    *values = append(*values, node.Val)
    inorder(node.Right, values)
}
```

## Дополнительные операции

### Minimum и Maximum

```go
func (bst *BST) Min() *TreeNode {
    if bst.Root == nil {
        return nil
    }
    return findMin(bst.Root)
}

func (bst *BST) Max() *TreeNode {
    if bst.Root == nil {
        return nil
    }
    return findMax(bst.Root)
}
```

### Kth Smallest Element

```go
func kthSmallest(root *TreeNode, k int) int {
    count := 0
    result := 0

    var inorder func(*TreeNode)
    inorder = func(node *TreeNode) {
        if node == nil || count >= k {
            return
        }

        inorder(node.Left)

        count++
        if count == k {
            result = node.Val
            return
        }

        inorder(node.Right)
    }

    inorder(root)
    return result
}
```

### Lowest Common Ancestor (LCA)

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }

    // Оба в левом поддереве
    if p.Val < root.Val && q.Val < root.Val {
        return lowestCommonAncestor(root.Left, p, q)
    }

    // Оба в правом поддереве
    if p.Val > root.Val && q.Val > root.Val {
        return lowestCommonAncestor(root.Right, p, q)
    }

    // Разные стороны (или один из них корень)
    return root
}
```

### Range Sum

```go
func rangeSumBST(root *TreeNode, low, high int) int {
    if root == nil {
        return 0
    }

    sum := 0

    // Текущий узел в диапазоне
    if root.Val >= low && root.Val <= high {
        sum += root.Val
    }

    // Искать в левом поддереве
    if root.Val > low {
        sum += rangeSumBST(root.Left, low, high)
    }

    // Искать в правом поддереве
    if root.Val < high {
        sum += rangeSumBST(root.Right, low, high)
    }

    return sum
}

// rangeSumBST(root, 7, 15) для дерева [10,5,15,3,7,13,18]
// → 7 + 10 + 13 + 15 = 45
```

## Построение BST

### Из отсортированного массива

```go
func sortedArrayToBST(nums []int) *TreeNode {
    if len(nums) == 0 {
        return nil
    }

    mid := len(nums) / 2

    root := &TreeNode{Val: nums[mid]}
    root.Left = sortedArrayToBST(nums[:mid])
    root.Right = sortedArrayToBST(nums[mid+1:])

    return root
}

// sortedArrayToBST([1,2,3,4,5,6,7])
//
//       4
//      / \
//     2   6
//    / \ / \
//   1  3 5  7
```

### Из Preorder

```go
func bstFromPreorder(preorder []int) *TreeNode {
    if len(preorder) == 0 {
        return nil
    }

    root := &TreeNode{Val: preorder[0]}

    // Найти первый элемент > root
    i := 1
    for i < len(preorder) && preorder[i] < root.Val {
        i++
    }

    root.Left = bstFromPreorder(preorder[1:i])
    root.Right = bstFromPreorder(preorder[i:])

    return root
}

// bstFromPreorder([8,5,1,7,10,12])
//
//       8
//      / \
//     5   10
//    / \    \
//   1   7   12
```

## Сложность операций

| Операция | Best Case | Average Case | Worst Case |
|----------|-----------|--------------|------------|
| Поиск | O(log n) | O(log n) | O(n) |
| Вставка | O(log n) | O(log n) | O(n) |
| Удаление | O(log n) | O(log n) | O(n) |

**Worst case:** дерево вырождено в список

```
1
 \
  2
   \
    3
     \
      4  ← O(n) для поиска 4
```

## BST vs Hash Table

| Свойство | BST | Hash Table |
|----------|-----|------------|
| Поиск | O(log n) | O(1) |
| Вставка | O(log n) | O(1) |
| Удаление | O(log n) | O(1) |
| Упорядоченность | ✅ | ❌ |
| Range queries | ✅ O(log n + k) | ❌ |
| Min/Max | ✅ O(log n) | ❌ O(n) |
| Память | Меньше | Больше |

**Когда использовать BST:**
- Нужна упорядоченность
- Range queries
- Найти k-й элемент
- Найти predecessor/successor

**Когда использовать Hash Table:**
- Только точный поиск
- Нужна максимальная скорость
- Порядок не важен

## Балансировка

Несбалансированное BST может деградировать до O(n).

**Решение:** Самобалансирующиеся деревья
- [[AVL и Red-Black деревья]]
- Treap
- Splay Tree

## Практические задачи

### 1. Contains Duplicate (with BST)

```go
func containsDuplicate(nums []int) bool {
    bst := NewBST()

    for _, num := range nums {
        if bst.Search(num) != nil {
            return true
        }
        bst.Insert(num)
    }

    return false
}
```

### 2. Two Sum IV (BST)

```go
func findTarget(root *TreeNode, k int) bool {
    seen := make(map[int]bool)

    var dfs func(*TreeNode) bool
    dfs = func(node *TreeNode) bool {
        if node == nil {
            return false
        }

        complement := k - node.Val
        if seen[complement] {
            return true
        }

        seen[node.Val] = true

        return dfs(node.Left) || dfs(node.Right)
    }

    return dfs(root)
}
```

### 3. Trim BST

```go
func trimBST(root *TreeNode, low, high int) *TreeNode {
    if root == nil {
        return nil
    }

    if root.Val < low {
        // Узел слишком мал, ищем в правом поддереве
        return trimBST(root.Right, low, high)
    }

    if root.Val > high {
        // Узел слишком велик, ищем в левом поддереве
        return trimBST(root.Left, low, high)
    }

    // Узел в диапазоне, обрабатываем поддеревья
    root.Left = trimBST(root.Left, low, high)
    root.Right = trimBST(root.Right, low, high)

    return root
}
```

## Best Practices

1. ✅ Проверяйте nil перед доступом к узлу
2. ✅ Используйте рекурсию для простоты
3. ✅ Для больших данных рассмотрите самобалансирующиеся деревья
4. ✅ In-order обход для получения sorted list
5. ✅ Используйте границы для валидации BST
6. ❌ Не игнорируйте балансировку в production
7. ❌ Не забывайте обрабатывать дубликаты

## Связанные темы

- [[Деревья - Основы]]
- [[AVL и Red-Black деревья]]
- [[Heap (куча)]]
- [[HashMap - Реализация и особенности]]
- [[Бинарный поиск]]
- [[Алгоритмическая сложность (Big O)]]
