# Деревья - Основы

Иерархическая структура данных из узлов, связанных рёбрами.

## Терминология

```
        1         ← Root (корень)
       / \
      2   3       ← Internal nodes (внутренние узлы)
     / \   \
    4   5   6     ← Leaves (листья)
```

- **Root** - корень, верхний узел
- **Parent** - родитель узла
- **Child** - дочерний узел
- **Siblings** - узлы с одним родителем
- **Leaf** - узел без детей
- **Internal node** - узел с детьми
- **Edge** - связь между узлами
- **Path** - последовательность узлов
- **Height** - максимальная длина пути от узла до листа
- **Depth** - длина пути от корня до узла
- **Level** - depth + 1

## Бинарное дерево

Каждый узел имеет не более 2 детей.

### Структура

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func NewNode(val int) *TreeNode {
    return &TreeNode{Val: val}
}
```

### Создание дерева

```go
//     1
//    / \
//   2   3
//  / \
// 4   5

root := NewNode(1)
root.Left = NewNode(2)
root.Right = NewNode(3)
root.Left.Left = NewNode(4)
root.Left.Right = NewNode(5)
```

## Обход дерева

### 1. In-order (Left → Root → Right)

```go
func inorder(root *TreeNode) {
    if root == nil {
        return
    }

    inorder(root.Left)        // Левое поддерево
    fmt.Print(root.Val, " ")  // Корень
    inorder(root.Right)       // Правое поддерево
}

// Для BST даёт отсортированный порядок: 4 2 5 1 3
```

### 2. Pre-order (Root → Left → Right)

```go
func preorder(root *TreeNode) {
    if root == nil {
        return
    }

    fmt.Print(root.Val, " ")  // Корень
    preorder(root.Left)       // Левое поддерево
    preorder(root.Right)      // Правое поддерево
}

// Результат: 1 2 4 5 3
```

### 3. Post-order (Left → Right → Root)

```go
func postorder(root *TreeNode) {
    if root == nil {
        return
    }

    postorder(root.Left)      // Левое поддерево
    postorder(root.Right)     // Правое поддерево
    fmt.Print(root.Val, " ")  // Корень
}

// Результат: 4 5 2 3 1
```

### 4. Level-order (BFS)

```go
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        levelSize := len(queue)
        level := []int{}

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]

            level = append(level, node.Val)

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        result = append(result, level)
    }

    return result
}

// Результат: [[1], [2,3], [4,5]]
```

## Итеративный обход (без рекурсии)

### In-order итеративно

```go
func inorderIterative(root *TreeNode) []int {
    result := []int{}
    stack := []*TreeNode{}
    current := root

    for current != nil || len(stack) > 0 {
        // Идем влево до конца
        for current != nil {
            stack = append(stack, current)
            current = current.Left
        }

        // Обрабатываем узел
        current = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, current.Val)

        // Идем вправо
        current = current.Right
    }

    return result
}
```

### Pre-order итеративно

```go
func preorderIterative(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }

    result := []int{}
    stack := []*TreeNode{root}

    for len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        result = append(result, node.Val)

        // Сначала правый (чтобы левый обработался раньше)
        if node.Right != nil {
            stack = append(stack, node.Right)
        }
        if node.Left != nil {
            stack = append(stack, node.Left)
        }
    }

    return result
}
```

## Типы бинарных деревьев

### 1. Full Binary Tree (полное)

Каждый узел имеет 0 или 2 детей.

```
     1
    / \
   2   3
  / \
 4   5
```

### 2. Complete Binary Tree (завершённое)

Все уровни заполнены, кроме последнего (заполняется слева).

```
     1
    / \
   2   3
  / \  /
 4  5 6
```

**Используется в heap!**

### 3. Perfect Binary Tree (совершенное)

Все уровни полностью заполнены.

```
     1
    / \
   2   3
  / \ / \
 4  5 6  7
```

Количество узлов: 2^h - 1 (где h - высота)

### 4. Balanced Binary Tree (сбалансированное)

Высота левого и правого поддеревьев отличается не более чем на 1.

```go
func isBalanced(root *TreeNode) bool {
    _, balanced := checkHeight(root)
    return balanced
}

func checkHeight(node *TreeNode) (int, bool) {
    if node == nil {
        return 0, true
    }

    leftHeight, leftBalanced := checkHeight(node.Left)
    if !leftBalanced {
        return 0, false
    }

    rightHeight, rightBalanced := checkHeight(node.Right)
    if !rightBalanced {
        return 0, false
    }

    balanced := abs(leftHeight-rightHeight) <= 1
    height := max(leftHeight, rightHeight) + 1

    return height, balanced
}
```

### 5. Degenerate Tree (вырожденное)

Каждый узел имеет только одного ребёнка (фактически linked list).

```
1
 \
  2
   \
    3
     \
      4
```

**Плохо для производительности!** O(n) операции.

## Основные операции

### Высота дерева

```go
func height(root *TreeNode) int {
    if root == nil {
        return 0
    }

    leftHeight := height(root.Left)
    rightHeight := height(root.Right)

    return max(leftHeight, rightHeight) + 1
}
```

### Количество узлов

```go
func countNodes(root *TreeNode) int {
    if root == nil {
        return 0
    }

    return 1 + countNodes(root.Left) + countNodes(root.Right)
}
```

### Максимальная глубина

```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    return 1 + max(maxDepth(root.Left), maxDepth(root.Right))
}
```

### Минимальная глубина

```go
func minDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    // Если один из детей nil, учитываем только другого
    if root.Left == nil {
        return 1 + minDepth(root.Right)
    }
    if root.Right == nil {
        return 1 + minDepth(root.Left)
    }

    return 1 + min(minDepth(root.Left), minDepth(root.Right))
}
```

### Сумма всех узлов

```go
func sumTree(root *TreeNode) int {
    if root == nil {
        return 0
    }

    return root.Val + sumTree(root.Left) + sumTree(root.Right)
}
```

### Зеркальное отображение

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }

    // Поменять детей местами
    root.Left, root.Right = root.Right, root.Left

    invertTree(root.Left)
    invertTree(root.Right)

    return root
}
```

### Проверка симметричности

```go
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    return isMirror(root.Left, root.Right)
}

func isMirror(left, right *TreeNode) bool {
    if left == nil && right == nil {
        return true
    }
    if left == nil || right == nil {
        return false
    }

    return left.Val == right.Val &&
        isMirror(left.Left, right.Right) &&
        isMirror(left.Right, right.Left)
}
```

### Path Sum

```go
func hasPathSum(root *TreeNode, targetSum int) bool {
    if root == nil {
        return false
    }

    // Лист
    if root.Left == nil && root.Right == nil {
        return root.Val == targetSum
    }

    remaining := targetSum - root.Val
    return hasPathSum(root.Left, remaining) ||
        hasPathSum(root.Right, remaining)
}
```

## Сложность операций

| Операция | Несбалансированное | Сбалансированное |
|----------|-------------------|------------------|
| Поиск | O(n) | O(log n) |
| Вставка | O(n) | O(log n) |
| Удаление | O(n) | O(log n) |
| Обход | O(n) | O(n) |

## Применение

### 1. Иерархии

```go
type FileSystem struct {
    Name     string
    IsDir    bool
    Children []*FileSystem
}
```

### 2. Expression Trees

```
     +
    / \
   *   3
  / \
 2   5

Представляет: (2 * 5) + 3
```

### 3. Huffman Coding

```go
type HuffmanNode struct {
    Char  rune
    Freq  int
    Left  *HuffmanNode
    Right *HuffmanNode
}
```

### 4. Abstract Syntax Tree (AST)

```go
// x = 5 + 3
//
//      =
//     / \
//    x   +
//       / \
//      5   3
```

## Best Practices

1. ✅ Используйте рекурсию для простоты
2. ✅ Итеративный обход для избежания stack overflow
3. ✅ BFS для level-order обхода
4. ✅ DFS для поиска пути
5. ✅ Проверяйте nil перед обращением к узлу
6. ❌ Не забывайте про base case в рекурсии
7. ❌ Избегайте глубокой несбалансированности

## Связанные темы

- [[Бинарные деревья поиска]]
- [[AVL и Red-Black деревья]]
- [[Heap (куча)]]
- [[BFS и DFS]]
- [[Алгоритмическая сложность (Big O)]]
