# Сортировки - Быстрая, слиянием, пузырьком

Алгоритмы упорядочивания элементов массива.

## Сравнение алгоритмов

| Алгоритм | Best | Average | Worst | Memory | Stable |
|----------|------|---------|-------|--------|--------|
| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ |
| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) | ❌ |
| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ |
| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ |
| Quick Sort | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ |
| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ |

**Stable** = сохраняет относительный порядок равных элементов

## Bubble Sort (пузырьковая)

Многократно проходит по массиву, сравнивая соседние элементы и меняя их местами.

```go
func bubbleSort(arr []int) {
    n := len(arr)

    for i := 0; i < n; i++ {
        swapped := false

        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = true
            }
        }

        // Оптимизация: если не было обменов, массив отсортирован
        if !swapped {
            break
        }
    }
}
```

**Пример:**

```
[5, 1, 4, 2, 8]

Проход 1: [1, 4, 2, 5, 8]  (8 на месте)
Проход 2: [1, 2, 4, 5, 8]  (5 на месте)
Проход 3: [1, 2, 4, 5, 8]  (4 на месте)
```

**Сложность:**
- Время: O(n²)
- Память: O(1)
- Stable: ✅

**Когда использовать:**
- Очень малые данные (n < 10)
- Почти отсортированные данные
- Обучение

## Selection Sort (сортировка выбором)

Находит минимум и ставит в начало.

```go
func selectionSort(arr []int) {
    n := len(arr)

    for i := 0; i < n-1; i++ {
        // Найти индекс минимума
        minIdx := i
        for j := i + 1; j < n; j++ {
            if arr[j] < arr[minIdx] {
                minIdx = j
            }
        }

        // Поменять местами
        arr[i], arr[minIdx] = arr[minIdx], arr[i]
    }
}
```

**Сложность:**
- Время: O(n²) (всегда!)
- Память: O(1)
- Stable: ❌

## Insertion Sort (сортировка вставками)

Вставляет каждый элемент в отсортированную часть.

```go
func insertionSort(arr []int) {
    n := len(arr)

    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1

        // Сдвигаем элементы > key вправо
        for j >= 0 && arr[j] > key {
            arr[j+1] = arr[j]
            j--
        }

        arr[j+1] = key
    }
}
```

**Пример:**

```
[5, 2, 4, 6, 1, 3]

i=1: [2, 5, 4, 6, 1, 3]
i=2: [2, 4, 5, 6, 1, 3]
i=3: [2, 4, 5, 6, 1, 3]
i=4: [1, 2, 4, 5, 6, 3]
i=5: [1, 2, 3, 4, 5, 6]
```

**Сложность:**
- Время: O(n²), O(n) для почти отсортированных
- Память: O(1)
- Stable: ✅

**Когда использовать:**
- Малые данные
- Почти отсортированные данные
- Online sorting (добавление элементов по одному)

## Merge Sort (сортировка слиянием)

Divide and Conquer: разделяй и сливай.

```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }

    // Разделить
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])

    // Слить
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0

    // Слияние отсортированных частей
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }

    // Добавить остатки
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)

    return result
}
```

**In-place версия:**

```go
func mergeSortInPlace(arr []int, left, right int) {
    if left >= right {
        return
    }

    mid := left + (right-left)/2

    mergeSortInPlace(arr, left, mid)
    mergeSortInPlace(arr, mid+1, right)

    mergeInPlace(arr, left, mid, right)
}

func mergeInPlace(arr []int, left, mid, right int) {
    temp := make([]int, right-left+1)
    i, j, k := left, mid+1, 0

    for i <= mid && j <= right {
        if arr[i] <= arr[j] {
            temp[k] = arr[i]
            i++
        } else {
            temp[k] = arr[j]
            j++
        }
        k++
    }

    for i <= mid {
        temp[k] = arr[i]
        i++
        k++
    }

    for j <= right {
        temp[k] = arr[j]
        j++
        k++
    }

    for i := 0; i < len(temp); i++ {
        arr[left+i] = temp[i]
    }
}

// Использование
arr := []int{5, 2, 4, 6, 1, 3}
mergeSortInPlace(arr, 0, len(arr)-1)
```

**Пример:**

```
[5, 2, 4, 6, 1, 3]

Разделить:
[5, 2, 4] [6, 1, 3]
[5] [2, 4] [6] [1, 3]
[5] [2] [4] [6] [1] [3]

Слить:
[5] [2, 4] [6] [1, 3]
[2, 4, 5] [1, 3, 6]
[1, 2, 3, 4, 5, 6]
```

**Сложность:**
- Время: O(n log n) (всегда!)
- Память: O(n)
- Stable: ✅

**Когда использовать:**
- Гарантированная O(n log n)
- Нужна стабильность
- Внешняя сортировка (не помещается в память)

## Quick Sort (быстрая сортировка)

Выбирает pivot, разделяет массив.

```go
func quickSort(arr []int, low, high int) {
    if low < high {
        // Разделить
        pivotIdx := partition(arr, low, high)

        // Сортировать части
        quickSort(arr, low, pivotIdx-1)
        quickSort(arr, pivotIdx+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]  // Последний элемент как pivot
    i := low - 1

    for j := low; j < high; j++ {
        if arr[j] <= pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }

    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

// Использование
arr := []int{5, 2, 4, 6, 1, 3}
quickSort(arr, 0, len(arr)-1)
```

**Выбор pivot:**

```go
// 1. Случайный pivot (избежать worst case)
func randomizedPartition(arr []int, low, high int) int {
    rand.Seed(time.Now().UnixNano())
    pivotIdx := low + rand.Intn(high-low+1)
    arr[pivotIdx], arr[high] = arr[high], arr[pivotIdx]
    return partition(arr, low, high)
}

// 2. Median-of-three (медиана из трёх)
func medianOfThree(arr []int, low, high int) int {
    mid := low + (high-low)/2

    if arr[low] > arr[mid] {
        arr[low], arr[mid] = arr[mid], arr[low]
    }
    if arr[low] > arr[high] {
        arr[low], arr[high] = arr[high], arr[low]
    }
    if arr[mid] > arr[high] {
        arr[mid], arr[high] = arr[high], arr[mid]
    }

    arr[mid], arr[high] = arr[high], arr[mid]
    return partition(arr, low, high)
}
```

**Пример:**

```
[5, 2, 4, 6, 1, 3]  pivot=3

Partition: [2, 1, 3, 6, 5, 4]
           меньше↑ ↑больше

Рекурсия:
[2, 1] | 3 | [6, 5, 4]
[1, 2] | 3 | [4, 5, 6]
```

**Сложность:**
- Время: O(n log n) average, O(n²) worst
- Память: O(log n) (стек рекурсии)
- Stable: ❌

**Когда использовать:**
- По умолчанию для общих случаев
- Хороший average case
- In-place сортировка

## Heap Sort

Использует [[Heap (куча)]].

```go
func heapSort(arr []int) {
    n := len(arr)

    // Build max heap
    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }

    // Extract elements
    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]  // Swap
        heapify(arr, i, 0)
    }
}

func heapify(arr []int, n, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2

    if left < n && arr[left] > arr[largest] {
        largest = left
    }

    if right < n && arr[right] > arr[largest] {
        largest = right
    }

    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}
```

**Сложность:**
- Время: O(n log n) (всегда!)
- Память: O(1)
- Stable: ❌

## Go sort.Slice

Стандартная библиотека Go:

```go
import "sort"

// Сортировка чисел
nums := []int{5, 2, 4, 6, 1, 3}
sort.Ints(nums)

// Сортировка строк
strs := []string{"banana", "apple", "cherry"}
sort.Strings(strs)

// Кастомная сортировка
sort.Slice(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

// Обратная сортировка
sort.Slice(nums, func(i, j int) bool {
    return nums[i] > nums[j]
})

// Стабильная сортировка
sort.SliceStable(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})
```

**Сложность sort.Slice:**
- Алгоритм: Introsort (Quick + Heap)
- Время: O(n log n)
- Unstable (используйте SliceStable для стабильности)

## Counting Sort (сортировка подсчётом)

Для целых чисел в известном диапазоне.

```go
func countingSort(arr []int) []int {
    if len(arr) == 0 {
        return arr
    }

    // Найти min и max
    minVal, maxVal := arr[0], arr[0]
    for _, num := range arr {
        if num < minVal {
            minVal = num
        }
        if num > maxVal {
            maxVal = num
        }
    }

    // Подсчёт
    countRange := maxVal - minVal + 1
    count := make([]int, countRange)

    for _, num := range arr {
        count[num-minVal]++
    }

    // Кумулятивная сумма
    for i := 1; i < len(count); i++ {
        count[i] += count[i-1]
    }

    // Построить результат
    result := make([]int, len(arr))
    for i := len(arr) - 1; i >= 0; i-- {
        num := arr[i]
        idx := count[num-minVal] - 1
        result[idx] = num
        count[num-minVal]--
    }

    return result
}
```

**Сложность:**
- Время: O(n + k), где k = диапазон
- Память: O(k)
- Stable: ✅

**Когда использовать:**
- Малый диапазон чисел (k ≈ n)
- Целые числа

## Выбор алгоритма

**Малые данные (n < 50):**
- Insertion Sort

**Общий случай:**
- Quick Sort (average)
- Go sort.Slice

**Гарантия O(n log n):**
- Merge Sort
- Heap Sort

**Нужна стабильность:**
- Merge Sort
- sort.SliceStable

**Целые числа, малый диапазон:**
- Counting Sort

**Внешняя сортировка (большие файлы):**
- Merge Sort

## Best Practices

1. ✅ Используйте sort.Slice для большинства случаев
2. ✅ Quick Sort для общих случаев
3. ✅ Merge Sort для гарантии O(n log n)
4. ✅ Counting Sort для целых чисел
5. ✅ Insertion Sort для малых данных
6. ❌ Не используйте Bubble/Selection в production
7. ❌ Помните о стабильности

## Связанные темы

- [[Heap (куча)]]
- [[Бинарный поиск]]
- [[Алгоритмическая сложность (Big O)]]
- [[Временная и пространственная сложность]]
