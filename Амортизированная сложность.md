# Амортизированная сложность

Средняя стоимость операции при выполнении последовательности операций.

## Концепция

**Амортизированная сложность** - это среднее время на операцию в худшем случае для последовательности операций.

Отличие от average case:
- **Average case** - среднее по всем возможным входным данным
- **Amortized** - среднее по последовательности операций в худшем случае

## Классический пример: Dynamic Array (append)

### Go slice append

```go
s := []int{}
for i := 0; i < n; i++ {
    s = append(s, i)  // Амортизированное O(1)
}
```

### Как это работает

```
Capacity:  1 → 2 → 4 → 8 → 16 → ...
Append:    1   1   2   4    8

Операция 1: выделить [1], скопировать 0 элементов, вставить → 1 операция
Операция 2: выделить [2], скопировать 1 элемент,  вставить → 2 операции
Операция 3: вставить в [2] → 1 операция
Операция 4: выделить [4], скопировать 2 элемента, вставить → 3 операции
Операция 5: вставить в [4] → 1 операция
...
```

### Анализ

Для n операций append:
- Реаллокации происходят при: 1, 2, 4, 8, 16, ..., 2^k где 2^k ≤ n
- Стоимость реаллокации = количество копируемых элементов
- Общая стоимость копирований: 1 + 2 + 4 + 8 + ... + n = 2n - 1

**Итого:** O(2n) операций для n append → O(1) амортизированное

## Методы анализа

### 1. Aggregate Method (совокупный)

Суммируем стоимость всех операций и делим на количество.

**Пример:** append в slice

```
n операций append:
- Копирования: 1 + 2 + 4 + ... ≈ 2n
- Вставки: n
Итого: 3n операций
Амортизированная стоимость: 3n / n = 3 = O(1)
```

### 2. Accounting Method (бухгалтерский)

Назначаем каждой операции стоимость так, чтобы накопленная стоимость покрывала реальную.

**Пример:** append

```
Назначим каждой операции append стоимость 3:
- 1 "рубль" на саму вставку
- 2 "рубля" откладываем

Когда нужно копирование:
- Используем отложенные "рубли"
- Хватает для покрытия копирования
```

### 3. Potential Method (потенциальный)

Определяем потенциальную функцию, отражающую "накопленную работу".

```
Φ(i) = 2i - 2^(⌈log₂(i+1)⌉)

Амортизированная стоимость =
    Реальная стоимость + Δ потенциал
```

## Примеры структур данных

### Stack с двумя операциями

```go
type Stack struct {
    data []int
}

func (s *Stack) Push(x int) {  // O(1) амортизированное
    s.data = append(s.data, x)
}

func (s *Stack) Pop() int {     // O(1)
    x := s.data[len(s.data)-1]
    s.data = s.data[:len(s.data)-1]
    return x
}
```

**Анализ:**
- Pop всегда O(1)
- Push - O(1) амортизированное (как append)

### MultiPop операция

```go
func (s *Stack) MultiPop(k int) []int {
    result := []int{}
    for i := 0; i < k && len(s.data) > 0; i++ {
        result = append(result, s.Pop())
    }
    return result
}
```

**Последовательность n операций (Push/Pop/MultiPop):**
- Каждый элемент можно вытолкнуть только один раз
- Максимум n Pop операций всего
- Амортизированная стоимость любой операции: O(1)

### Binary Counter (двоичный счетчик)

```go
type Counter struct {
    bits []bool  // bits[0] - младший бит
}

func (c *Counter) Increment() {
    i := 0
    // Переворачиваем биты пока не встретим 0
    for i < len(c.bits) && c.bits[i] {
        c.bits[i] = false
        i++
    }
    if i == len(c.bits) {
        c.bits = append(c.bits, true)
    } else {
        c.bits[i] = true
    }
}
```

**Анализ:**
- Младший бит переворачивается каждый раз: n раз
- Бит 1 переворачивается каждый 2-й раз: n/2 раз
- Бит 2 переворачивается каждый 4-й раз: n/4 раз
- ...
- Всего переворотов: n + n/2 + n/4 + ... ≈ 2n
- Амортизированная стоимость: O(1)

### Hash Table с rehashing

```go
type HashTable struct {
    buckets [][]KeyValue
    size    int
    count   int
}

func (ht *HashTable) Insert(key, value string) {
    // Вставка O(1)
    bucket := hash(key) % ht.size
    ht.buckets[bucket] = append(ht.buckets[bucket], KeyValue{key, value})
    ht.count++

    // Rehash если load factor > 0.75
    if float64(ht.count) / float64(ht.size) > 0.75 {
        ht.rehash()  // O(n), но редко
    }
}
```

**Анализ:**
- Обычная вставка: O(1)
- Rehashing происходит при размерах: 1, 2, 4, 8, ...
- Стоимость rehash: копирование всех элементов
- Амортизированная стоимость Insert: O(1)

## Реальные примеры в Go

### strings.Builder

```go
var builder strings.Builder
for i := 0; i < n; i++ {
    builder.WriteString("text")  // O(1) амортизированное
}
```

Внутри использует аналогичную стратегию роста буфера.

### map (теоретически)

```go
m := make(map[string]int)
for i := 0; i < n; i++ {
    m[fmt.Sprintf("key%d", i)] = i  // O(1) амортизированное
}
```

При росте таблицы происходит rehashing, но амортизированная сложность остается O(1).

## Worst Case vs Amortized

### Пример с append

```go
s := make([]int, 0, 8)

// Операции 1-8: O(1) каждая (есть capacity)
for i := 0; i < 8; i++ {
    s = append(s, i)
}

// Операция 9: O(n) - нужна реаллокация!
s = append(s, 9)

// Операции 10-16: O(1) каждая
for i := 10; i < 17; i++ {
    s = append(s, i)
}
```

**Worst case одной операции:** O(n)
**Amortized для всех операций:** O(1)

## Когда важна амортизированная сложность

✅ **Полезно когда:**
- Дорогие операции редки
- Анализируем множество операций
- Проектируем структуры данных
- Оцениваем общую производительность

❌ **Не подходит когда:**
- Нужны гарантии времени отклика
- Real-time системы
- Критичная latency для каждой операции

### Real-time системы

```go
// ❌ Плохо для real-time: append может вызвать O(n) задержку
func processRealTime(data int) {
    buffer = append(buffer, data)  // Непредсказуемое время!
}

// ✅ Хорошо: pre-allocate или ring buffer
func processRealTime(data int) {
    if bufferIndex < len(buffer) {
        buffer[bufferIndex] = data  // O(1) гарантированно
        bufferIndex++
    }
}
```

## Сравнение с другими оценками

| Оценка | Что показывает | Пример |
|--------|----------------|--------|
| Worst case | Максимальное время одной операции | append: O(n) |
| Best case | Минимальное время одной операции | append: O(1) |
| Average case | Среднее по разным входным данным | Quicksort: O(n log n) |
| Amortized | Среднее время в последовательности операций | append: O(1) |

## Best Practices

1. ✅ Используйте для анализа последовательности операций
2. ✅ Pre-allocate когда знаете размер (избегайте амортизации)
3. ✅ Понимайте разницу между amortized и worst case
4. ✅ Измеряйте реальную производительность
5. ❌ Не полагайтесь на амортизацию в real-time системах
6. ❌ Не путайте с average case

## Оптимизация

### Избежать реаллокаций

```go
// ❌ Амортизированное O(1), но с реаллокациями
s := []int{}
for i := 0; i < 1000000; i++ {
    s = append(s, i)
}

// ✅ O(1) без реаллокаций
s := make([]int, 0, 1000000)
for i := 0; i < 1000000; i++ {
    s = append(s, i)
}
```

### Контроль роста

```go
// strings.Builder с Grow
var builder strings.Builder
builder.Grow(expectedSize)  // Pre-allocate
for i := 0; i < n; i++ {
    builder.WriteString("text")
}
```

## Связанные темы

- [[Алгоритмическая сложность (Big O)]]
- [[Временная и пространственная сложность]]
- [[Go - Массивы и слайсы]]
- [[Go - Управление памятью]]
