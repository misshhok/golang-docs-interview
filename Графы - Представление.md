# Графы - Представление

Граф G = (V, E) - набор вершин (vertices) и рёбер (edges) между ними.

## Типы графов

### 1. Ориентированный (Directed Graph)

Рёбра имеют направление: A → B

```
    1 → 2
    ↓   ↓
    3 → 4
```

### 2. Неориентированный (Undirected Graph)

Рёбра двусторонние: A ↔ B

```
    1 — 2
    |   |
    3 — 4
```

### 3. Взвешенный (Weighted Graph)

Рёбра имеют вес (стоимость)

```
    1 —5— 2
    |     |
    3     8
    |     |
    3 —2— 4
```

### 4. Невзвешенный (Unweighted Graph)

Все рёбра равны (или вес = 1)

## Представления графа

### 1. Adjacency Matrix (матрица смежности)

```
Граф:
  1 — 2
  |   |
  3 — 4

Matrix (4×4):
    1  2  3  4
1 [ 0  1  1  0 ]
2 [ 1  0  0  1 ]
3 [ 1  0  0  1 ]
4 [ 0  1  1  0 ]

matrix[i][j] = 1, если есть ребро i → j
```

```go
type GraphMatrix struct {
    vertices int
    matrix   [][]int
}

func NewGraphMatrix(n int) *GraphMatrix {
    matrix := make([][]int, n)
    for i := range matrix {
        matrix[i] = make([]int, n)
    }

    return &GraphMatrix{
        vertices: n,
        matrix:   matrix,
    }
}

// Добавить ребро (неориентированный граф)
func (g *GraphMatrix) AddEdge(from, to int) {
    g.matrix[from][to] = 1
    g.matrix[to][from] = 1  // Двустороннее
}

// Для ориентированного графа
func (g *GraphMatrix) AddDirectedEdge(from, to int) {
    g.matrix[from][to] = 1
}

// Проверить наличие ребра
func (g *GraphMatrix) HasEdge(from, to int) bool {
    return g.matrix[from][to] == 1
}

// Для взвешенного графа
type WeightedGraphMatrix struct {
    vertices int
    matrix   [][]int  // matrix[i][j] = вес ребра или 0/∞
}

func (g *WeightedGraphMatrix) AddEdge(from, to, weight int) {
    g.matrix[from][to] = weight
    g.matrix[to][from] = weight
}
```

**Преимущества:**
- O(1) проверка наличия ребра
- Простая реализация

**Недостатки:**
- O(V²) памяти (плохо для разреженных графов)
- O(V) для получения всех соседей

### 2. Adjacency List (список смежности)

```
Граф:
  1 — 2
  |   |
  3 — 4

List:
1 → [2, 3]
2 → [1, 4]
3 → [1, 4]
4 → [2, 3]
```

```go
type Graph struct {
    vertices int
    adjList  map[int][]int
}

func NewGraph(n int) *Graph {
    return &Graph{
        vertices: n,
        adjList:  make(map[int][]int),
    }
}

// Добавить ребро (неориентированный)
func (g *Graph) AddEdge(from, to int) {
    g.adjList[from] = append(g.adjList[from], to)
    g.adjList[to] = append(g.adjList[to], from)
}

// Для ориентированного графа
func (g *Graph) AddDirectedEdge(from, to int) {
    g.adjList[from] = append(g.adjList[from], to)
}

// Получить соседей
func (g *Graph) Neighbors(v int) []int {
    return g.adjList[v]
}

// Проверить наличие ребра
func (g *Graph) HasEdge(from, to int) bool {
    for _, neighbor := range g.adjList[from] {
        if neighbor == to {
            return true
        }
    }
    return false
}
```

**Для взвешенного графа:**

```go
type Edge struct {
    to     int
    weight int
}

type WeightedGraph struct {
    vertices int
    adjList  map[int][]Edge
}

func (g *WeightedGraph) AddEdge(from, to, weight int) {
    g.adjList[from] = append(g.adjList[from], Edge{to, weight})
    g.adjList[to] = append(g.adjList[to], Edge{from, weight})
}
```

**Преимущества:**
- O(V + E) памяти (оптимально)
- O(degree) для получения соседей

**Недостатки:**
- O(degree) проверка наличия ребра

### 3. Edge List (список рёбер)

```
Граф:
  1 — 2
  |   |
  3 — 4

Edges:
[(1,2), (1,3), (2,4), (3,4)]
```

```go
type EdgeList struct {
    vertices int
    edges    [][2]int
}

func (el *EdgeList) AddEdge(from, to int) {
    el.edges = append(el.edges, [2]int{from, to})
}

// Для взвешенного графа
type WeightedEdge struct {
    from, to, weight int
}

type WeightedEdgeList struct {
    vertices int
    edges    []WeightedEdge
}
```

**Используется в:**
- Kruskal's MST
- Sorting edges

## Выбор представления

| Операция | Matrix | List | Edge List |
|----------|--------|------|-----------|
| Память | O(V²) | O(V+E) | O(E) |
| Добавить ребро | O(1) | O(1) | O(1) |
| Проверить ребро | O(1) | O(degree) | O(E) |
| Найти соседей | O(V) | O(degree) | O(E) |
| Перебрать все рёбра | O(V²) | O(V+E) | O(E) |

**Используйте Matrix когда:**
- Граф плотный (много рёбер)
- Частые проверки наличия ребра
- V небольшое (~1000)

**Используйте Adjacency List когда:**
- Граф разреженный (мало рёбер)
- Нужен обход (BFS/DFS)
- V большое

**Используйте Edge List когда:**
- Kruskal's algorithm
- Нужна сортировка рёбер

## Плотность графа

```
Плотный граф: E ≈ V²
Разреженный граф: E ≈ V

Для разреженного графа Adjacency List лучше!
```

## Примеры построения графа

### Из edge list

```go
func buildGraph(n int, edges [][]int) map[int][]int {
    graph := make(map[int][]int)

    for _, edge := range edges {
        from, to := edge[0], edge[1]
        graph[from] = append(graph[from], to)
        graph[to] = append(graph[to], from)  // Если неориентированный
    }

    return graph
}

// edges = [[0,1], [1,2], [2,0]]
// graph = {0:[1,2], 1:[0,2], 2:[1,0]}
```

### Из матрицы

```go
func buildGraphFromMatrix(matrix [][]int) map[int][]int {
    graph := make(map[int][]int)

    for i := range matrix {
        for j := range matrix[i] {
            if matrix[i][j] == 1 {
                graph[i] = append(graph[i], j)
            }
        }
    }

    return graph
}
```

## Специальные типы графов

### DAG (Directed Acyclic Graph)

Ориентированный граф без циклов.

```
    1 → 2
    ↓   ↓
    3 → 4
```

**Применение:**
- Топологическая сортировка
- Task scheduling
- Dependency resolution

### Дерево

Связный граф без циклов.

```
      1
     / \
    2   3
   / \
  4   5
```

**Свойства:**
- V вершин → V-1 рёбер
- Один путь между любыми двумя вершинами

### Двудольный граф (Bipartite)

Вершины можно разделить на два множества так, что рёбра только между множествами.

```
  A — 1
  |   |
  B — 2
  |   |
  C — 3

Множества: {A,B,C} и {1,2,3}
```

**Проверка:**

```go
func isBipartite(graph map[int][]int) bool {
    color := make(map[int]int)  // 0 или 1

    for node := range graph {
        if _, ok := color[node]; ok {
            continue
        }

        // BFS
        queue := []int{node}
        color[node] = 0

        for len(queue) > 0 {
            current := queue[0]
            queue = queue[1:]

            for _, neighbor := range graph[current] {
                if _, ok := color[neighbor]; !ok {
                    color[neighbor] = 1 - color[current]
                    queue = append(queue, neighbor)
                } else if color[neighbor] == color[current] {
                    return false  // Соседи одного цвета!
                }
            }
        }
    }

    return true
}
```

## Степень вершины (Degree)

### Неориентированный граф

```
degree(v) = количество рёбер, инцидентных v

    1 — 2
    |   |
    3 — 4

degree(1) = 2
degree(2) = 2
```

```go
func degree(graph map[int][]int, v int) int {
    return len(graph[v])
}
```

### Ориентированный граф

```
in-degree(v) = рёбра, входящие в v
out-degree(v) = рёбра, выходящие из v

    1 → 2
    ↓   ↓
    3 → 4

in-degree(2) = 1
out-degree(1) = 2
```

```go
func inDegree(graph map[int][]int) map[int]int {
    inDeg := make(map[int]int)

    for _, neighbors := range graph {
        for _, neighbor := range neighbors {
            inDeg[neighbor]++
        }
    }

    return inDeg
}

func outDegree(graph map[int][]int, v int) int {
    return len(graph[v])
}
```

## Связность

### Связный граф

Есть путь между любыми двумя вершинами.

```go
func isConnected(graph map[int][]int, n int) bool {
    if n == 0 {
        return true
    }

    visited := make(map[int]bool)
    dfs(graph, 0, visited)

    return len(visited) == n
}

func dfs(graph map[int][]int, node int, visited map[int]bool) {
    visited[node] = true

    for _, neighbor := range graph[node] {
        if !visited[neighbor] {
            dfs(graph, neighbor, visited)
        }
    }
}
```

### Компоненты связности

```go
func countComponents(n int, edges [][]int) int {
    graph := buildGraph(n, edges)
    visited := make(map[int]bool)
    count := 0

    for i := 0; i < n; i++ {
        if !visited[i] {
            dfs(graph, i, visited)
            count++
        }
    }

    return count
}
```

## Цикл в графе

### Неориентированный граф (DFS)

```go
func hasCycle(graph map[int][]int) bool {
    visited := make(map[int]bool)

    for node := range graph {
        if !visited[node] {
            if hasCycleDFS(graph, node, -1, visited) {
                return true
            }
        }
    }

    return false
}

func hasCycleDFS(graph map[int][]int, node, parent int, visited map[int]bool) bool {
    visited[node] = true

    for _, neighbor := range graph[node] {
        if !visited[neighbor] {
            if hasCycleDFS(graph, neighbor, node, visited) {
                return true
            }
        } else if neighbor != parent {
            return true  // Цикл найден!
        }
    }

    return false
}
```

### Ориентированный граф (DFS + recursion stack)

```go
func hasCycleDirected(graph map[int][]int) bool {
    visited := make(map[int]bool)
    recStack := make(map[int]bool)

    for node := range graph {
        if hasCycleDirectedDFS(graph, node, visited, recStack) {
            return true
        }
    }

    return false
}

func hasCycleDirectedDFS(graph map[int][]int, node int, visited, recStack map[int]bool) bool {
    if recStack[node] {
        return true  // Узел в текущем пути → цикл
    }

    if visited[node] {
        return false
    }

    visited[node] = true
    recStack[node] = true

    for _, neighbor := range graph[node] {
        if hasCycleDirectedDFS(graph, neighbor, visited, recStack) {
            return true
        }
    }

    recStack[node] = false  // Убрать из пути
    return false
}
```

## Применение графов

1. **Социальные сети** - граф друзей
2. **Карты** - города и дороги
3. **Интернет** - веб-страницы и ссылки
4. **Зависимости** - пакеты, задачи
5. **Нейросети** - вычислительный граф

## Best Practices

1. ✅ Adjacency List для большинства случаев
2. ✅ Matrix только для плотных графов
3. ✅ Храните visited для избежания бесконечных циклов
4. ✅ DFS для поиска путей, циклов
5. ✅ BFS для кратчайших путей
6. ❌ Не забывайте обрабатывать disconnected компоненты
7. ❌ Не используйте Matrix для больших разреженных графов

## Связанные темы

- [[BFS и DFS]]
- [[Деревья - Основы]]
- [[HashMap - Реализация и особенности]]
- [[Алгоритмическая сложность (Big O)]]
