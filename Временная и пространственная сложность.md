# Временная и пространственная сложность

Два основных аспекта анализа алгоритмов: время выполнения и использование памяти.

## Временная сложность (Time Complexity)

Сколько времени требуется алгоритму в зависимости от размера входных данных.

### Обозначение

- **O(n)** - Big O notation (верхняя граница, worst case)
- **Ω(n)** - Omega (нижняя граница, best case)
- **Θ(n)** - Theta (точная оценка, average case)

**На практике чаще используется Big O.**

### Примеры

```go
// O(1) - константное время
func getFirst(arr []int) int {
    return arr[0]
}

// O(n) - линейное время
func sum(arr []int) int {
    total := 0
    for _, num := range arr {
        total += num
    }
    return total
}

// O(n²) - квадратичное время
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

// O(log n) - логарифмическое время
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    for left <= right {
        mid := (left + right) / 2
        if arr[mid] == target {
            return mid
        }
        if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}

// O(n log n) - линейно-логарифмическое
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    // ... реализация merge sort
}
```

### Сравнение

Для n = 1,000,000:

| Сложность | Операций | Описание |
|-----------|----------|----------|
| O(1) | 1 | Отлично |
| O(log n) | ~20 | Очень хорошо |
| O(n) | 1,000,000 | Хорошо |
| O(n log n) | ~20,000,000 | Приемлемо |
| O(n²) | 1,000,000,000,000 | Плохо |
| O(2ⁿ) | 2^1000000 | Невозможно |

## Пространственная сложность (Space Complexity)

Сколько дополнительной памяти требуется алгоритму.

### Примеры

```go
// O(1) - константная память
func sumInPlace(arr []int) int {
    total := 0  // Одна переменная
    for _, num := range arr {
        total += num
    }
    return total
}

// O(n) - линейная память
func reverse(arr []int) []int {
    result := make([]int, len(arr))  // Новый массив размера n
    for i := 0; i < len(arr); i++ {
        result[i] = arr[len(arr)-1-i]
    }
    return result
}

// O(n) - рекурсия (call stack)
func factorial(n int) int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n-1)  // Глубина стека = n
}

// O(n²) - квадратичная память
func createMatrix(n int) [][]int {
    matrix := make([][]int, n)
    for i := range matrix {
        matrix[i] = make([]int, n)  // n × n элементов
    }
    return matrix
}
```

### In-place vs Out-of-place

**In-place** - изменяет входные данные, O(1) дополнительной памяти:

```go
// In-place reverse
func reverseInPlace(arr []int) {
    left, right := 0, len(arr)-1
    for left < right {
        arr[left], arr[right] = arr[right], arr[left]
        left++
        right--
    }
}
```

**Out-of-place** - создает новую структуру данных:

```go
// Out-of-place reverse
func reverseOutOfPlace(arr []int) []int {
    result := make([]int, len(arr))  // O(n) памяти
    for i := 0; i < len(arr); i++ {
        result[i] = arr[len(arr)-1-i]
    }
    return result
}
```

## Анализ алгоритмов

### Правила подсчета

1. **Константы игнорируются:**
   - O(2n) = O(n)
   - O(n + 1000) = O(n)

2. **Доминирующие члены:**
   - O(n² + n) = O(n²)
   - O(n log n + n) = O(n log n)

3. **Вложенные циклы перемножаются:**
   ```go
   for i := 0; i < n; i++ {      // O(n)
       for j := 0; j < n; j++ {  // O(n)
           // O(1)
       }
   }
   // Итого: O(n × n) = O(n²)
   ```

4. **Последовательные операции складываются:**
   ```go
   for i := 0; i < n; i++ {  // O(n)
       // ...
   }
   for j := 0; j < m; j++ {  // O(m)
       // ...
   }
   // Итого: O(n + m)
   ```

### Примеры анализа

**Пример 1:**
```go
func example1(arr []int) int {
    sum := 0                    // O(1) время, O(1) память
    for _, num := range arr {   // O(n) время
        sum += num              // O(1) время
    }
    return sum
}
// Временная: O(n)
// Пространственная: O(1)
```

**Пример 2:**
```go
func example2(arr []int) []int {
    result := []int{}           // O(1) память изначально
    for _, num := range arr {   // O(n) время
        for j := 0; j < num; j++ {  // O(num) время
            result = append(result, j)  // амортизированное O(1)
        }
    }
    return result
}
// Временная: O(n × max(arr))
// Пространственная: O(размер result)
```

**Пример 3:**
```go
func example3(n int) int {
    if n <= 1 {
        return 1
    }
    return example3(n-1) + example3(n-1)
}
// Временная: O(2ⁿ) - экспоненциальная!
// Пространственная: O(n) - глубина стека
```

## Trade-offs

Часто приходится выбирать между временем и памятью:

### Кэширование (Memoization)

```go
// Без кэша: O(2ⁿ) время, O(n) память
func fibSlow(n int) int {
    if n <= 1 {
        return n
    }
    return fibSlow(n-1) + fibSlow(n-2)
}

// С кэшем: O(n) время, O(n) память
func fibFast(n int, cache map[int]int) int {
    if n <= 1 {
        return n
    }
    if val, ok := cache[n]; ok {
        return val
    }
    cache[n] = fibFast(n-1, cache) + fibFast(n-2, cache)
    return cache[n]
}
```

### Pre-computation

```go
// Больше памяти, меньше времени
type LookupTable struct {
    data map[string]int  // O(n) память
}

func (lt *LookupTable) Get(key string) int {
    return lt.data[key]  // O(1) время
}
```

## Практические соображения

### Размер входных данных

- n < 10: O(n!) может быть OK
- n < 1000: O(n²) приемлемо
- n < 1,000,000: O(n log n) хорошо
- n > 1,000,000: нужно O(n) или O(log n)

### Реальная производительность

Big O не учитывает константы:

```go
// Алгоритм A: O(n), но константа = 1000
func algorithmA(arr []int) {
    for i := 0; i < 1000; i++ {
        for _, num := range arr {
            _ = num
        }
    }
}

// Алгоритм B: O(n²), но константа = 1
func algorithmB(arr []int) {
    for i := range arr {
        for j := i + 1; j < len(arr); j++ {
            _ = arr[i] + arr[j]
        }
    }
}
```

Для малых n алгоритм B может быть быстрее!

## Амортизированная сложность

Когда отдельные операции дороги, но в среднем дешевы.

### append в Go

```go
s := []int{}
for i := 0; i < n; i++ {
    s = append(s, i)  // Амортизированное O(1)
}
```

**Почему:**
- Большинство append - O(1)
- Редкие реаллокации - O(n)
- В среднем: O(1) амортизированное

Подробнее: [[Амортизированная сложность]]

## Best Practices

1. ✅ Всегда анализируйте worst case (Big O)
2. ✅ Учитывайте и время, и память
3. ✅ Измеряйте на реальных данных
4. ✅ Помните о константах для малых n
5. ✅ Оптимизируйте узкие места, не весь код
6. ❌ Не оптимизируйте преждевременно
7. ❌ Не игнорируйте пространственную сложность

## Связанные темы

- [[Алгоритмическая сложность (Big O)]]
- [[Амортизированная сложность]]
- [[Go - Массивы и слайсы]]
- [[Go - Управление памятью]]
