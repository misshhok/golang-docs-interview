# Go - Внутреннее устройство map

Map в Go — это хеш-таблица, реализованная как массив бакетов (buckets). Понимание внутреннего устройства критически важно для оптимизации производительности и избежания типичных ошибок.

## Структура map

### Основные компоненты

```go
// runtime/map.go (упрощённо)
type hmap struct {
    count     int    // количество элементов
    flags     uint8  // состояние map
    B         uint8  // log2 количества бакетов (buckets = 2^B)
    noverflow uint16 // приблизительное количество overflow бакетов
    hash0     uint32 // seed для хеш-функции

    buckets    unsafe.Pointer // массив из 2^B бакетов
    oldbuckets unsafe.Pointer // старые бакеты (при эвакуации)
    nevacuate  uintptr        // прогресс эвакуации

    extra *mapextra // дополнительные данные
}
```

```
┌─────────────────────────────────────────────────────────────────┐
│                           HMAP                                   │
├─────────────────────────────────────────────────────────────────┤
│  count: 5        B: 2 (4 бакета)       hash0: 0x12345678        │
├─────────────────────────────────────────────────────────────────┤
│                          buckets ──────────────────┐            │
│                                                     ▼            │
│  ┌──────────┬──────────┬──────────┬──────────┐                  │
│  │ bucket 0 │ bucket 1 │ bucket 2 │ bucket 3 │   (2^B = 4)      │
│  └──────────┴──────────┴──────────┴──────────┘                  │
└─────────────────────────────────────────────────────────────────┘
```

### Структура бакета

Каждый бакет может хранить до **8 пар ключ-значение**:

```go
// runtime/map.go
type bmap struct {
    tophash [8]uint8  // старшие 8 бит хеша для быстрого поиска
    // Далее идут (в памяти, не в структуре):
    // keys     [8]keytype
    // values   [8]valuetype
    // overflow *bmap
}
```

```
┌─────────────────────────────────────────────────────────────────┐
│                          BUCKET                                  │
├─────────────────────────────────────────────────────────────────┤
│  tophash[0] │ tophash[1] │ ... │ tophash[7]   (8 bytes)         │
├─────────────────────────────────────────────────────────────────┤
│  key[0]     │ key[1]     │ ... │ key[7]       (8 * keysize)     │
├─────────────────────────────────────────────────────────────────┤
│  value[0]   │ value[1]   │ ... │ value[7]     (8 * valuesize)   │
├─────────────────────────────────────────────────────────────────┤
│  overflow ──────────────────────────────────▶ [next bucket]     │
└─────────────────────────────────────────────────────────────────┘
```

### Почему ключи и значения хранятся отдельно?

```
// Если бы хранили вместе: key-value-key-value...
// Для map[int64]int8:
┌────────┬───┬────────┬───┬────────┬───┐
│  key   │val│  key   │val│  key   │val│   + padding!
│ 8 bytes│ 1 │ 8 bytes│ 1 │ 8 bytes│ 1 │
└────────┴───┴────────┴───┴────────┴───┘
= много потерянной памяти на выравнивание

// Как на самом деле: keys вместе, values вместе
┌────────┬────────┬────────┐┌───┬───┬───┐
│  key   │  key   │  key   ││val│val│val│   меньше padding
│ 8 bytes│ 8 bytes│ 8 bytes││ 1 │ 1 │ 1 │
└────────┴────────┴────────┘└───┴───┴───┘
```

## Хеширование и поиск

### Как находится бакет

```go
// Для ключа key:
hash := hashfunc(key, h.hash0)  // вычисляем хеш

// Младшие B бит определяют номер бакета
bucketIndex := hash & (1<<h.B - 1)  // = hash % len(buckets)

// Старшие 8 бит — tophash для быстрого сравнения
tophash := hash >> (64 - 8)
```

```
hash = 0xABCDEF1234567890
              ▲        ▲
              │        └── младшие B бит → номер бакета
              └── старшие 8 бит → tophash
```

### Алгоритм поиска

```
1. Вычислить hash(key)
2. Найти бакет по младшим B битам
3. В бакете сравнить tophash с каждым из 8 слотов
4. Если tophash совпал → сравнить полный ключ
5. Если не нашли → проверить overflow бакет
6. Повторять пока не найдём или не дойдём до конца цепочки
```

```go
// Псевдокод поиска
func mapaccess(h *hmap, key keytype) valuetype {
    hash := hashfunc(key, h.hash0)
    bucket := hash & (1<<h.B - 1)
    tophash := uint8(hash >> 56)

    b := h.buckets[bucket]
    for {
        for i := 0; i < 8; i++ {
            if b.tophash[i] != tophash {
                continue  // быстрая проверка tophash
            }
            if b.keys[i] == key {
                return b.values[i]  // нашли!
            }
        }
        b = b.overflow
        if b == nil {
            return zero  // не нашли
        }
    }
}
```

## Рост map (Growing)

### Load Factor

```go
// loadFactor = count / (2^B * 8)
// Если loadFactor > 6.5 → нужен рост
const loadFactorNum = 13
const loadFactorDen = 2  // 13/2 = 6.5
```

### Два типа роста

```go
// 1. Обычный рост (doubling)
// Слишком много элементов: count/buckets > 6.5
// → Удваиваем количество бакетов (B += 1)

// 2. Рост без увеличения (same-size grow)
// Слишком много overflow бакетов (много удалений создали "дыры")
// → Перестраиваем с тем же количеством бакетов
```

### Инкрементальная эвакуация

Рост происходит **постепенно**, не блокируя операции:

```
Состояние во время эвакуации:

┌─────────────────────────────────────────────────────────────┐
│                         HMAP                                 │
├─────────────────────────────────────────────────────────────┤
│  buckets ────────────▶ [новые бакеты, 2x размер]            │
│  oldbuckets ─────────▶ [старые бакеты]                      │
│  nevacuate: 2          (эвакуировано 2 бакета)              │
└─────────────────────────────────────────────────────────────┘

При каждом write/delete эвакуируем 1-2 старых бакета
```

```go
// При операциях записи:
func mapassign(h *hmap, key keytype) *valuetype {
    // Если идёт эвакуация — помогаем
    if h.oldbuckets != nil {
        growWork(h, bucket)  // эвакуируем 1-2 бакета
    }
    // ... остальная логика
}
```

### Куда попадают элементы при росте?

```
До роста (B=2, 4 бакета):
hash & 0b11 = номер бакета (0-3)

После роста (B=3, 8 бакетов):
hash & 0b111 = номер бакета (0-7)

Элемент из бакета N попадёт в бакет N или N+4:
- Если дополнительный бит = 0 → бакет N (нижняя половина)
- Если дополнительный бит = 1 → бакет N+4 (верхняя половина)
```

## Итерация по map

### Случайный порядок

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}

// Порядок СЛУЧАЙНЫЙ и может меняться между запусками
for k, v := range m {
    fmt.Println(k, v)
}
```

**Почему случайный?**

1. Go специально рандомизирует стартовую позицию итератора
2. Это предотвращает зависимость от порядка
3. Защита от HashDoS атак (злоумышленник не может предсказать порядок)

### Итерация во время модификации

```go
// ✅ Можно удалять текущий элемент
for k := range m {
    if shouldDelete(k) {
        delete(m, k)  // безопасно
    }
}

// ⚠️ Добавление может быть не замечено
for k := range m {
    m["new"] = 42  // может быть итерирован или нет
}
```

## Почему нельзя взять адрес элемента?

```go
m := map[string]int{"a": 1}

ptr := &m["a"]  // ❌ Ошибка компиляции!
// cannot take the address of m["a"]
```

**Причина:** При росте map элементы перемещаются в новые бакеты. Указатель стал бы невалидным.

```go
// Обходной путь: хранить указатели
m := map[string]*int{}
val := 42
m["a"] = &val
ptr := m["a"]  // ✅ Работает
```

## Конкурентный доступ

### Map НЕ потокобезопасен

```go
m := make(map[string]int)

// ❌ Data race!
go func() { m["a"] = 1 }()
go func() { m["b"] = 2 }()

// Даже чтение во время записи — UB!
go func() { _ = m["a"] }()  // ❌ Опасно
go func() { m["b"] = 2 }()
```

### Решения

```go
// 1. sync.Mutex
var mu sync.Mutex
var m = make(map[string]int)

mu.Lock()
m["key"] = value
mu.Unlock()

// 2. sync.RWMutex (для read-heavy)
var rw sync.RWMutex
var m = make(map[string]int)

rw.RLock()
v := m["key"]
rw.RUnlock()

rw.Lock()
m["key"] = value
rw.Unlock()

// 3. sync.Map (встроенная thread-safe map)
var m sync.Map

m.Store("key", value)
v, ok := m.Load("key")
m.Delete("key")
```

## Оптимизация

### Предвыделение размера

```go
// ❌ Много реаллокаций
m := make(map[string]int)
for i := 0; i < 10000; i++ {
    m[fmt.Sprint(i)] = i
}

// ✅ Одна аллокация
m := make(map[string]int, 10000)  // hint
for i := 0; i < 10000; i++ {
    m[fmt.Sprint(i)] = i
}
```

### Размер ключей и значений

```go
// Маленькие ключи/значения хранятся в бакетах напрямую
map[int]int      // эффективно

// Большие хранятся через указатели
map[[100]byte]string  // ключи — указатели
```

### Бенчмарк

```go
func BenchmarkMapWithHint(b *testing.B) {
    for i := 0; i < b.N; i++ {
        m := make(map[int]int, 1000)
        for j := 0; j < 1000; j++ {
            m[j] = j
        }
    }
}

func BenchmarkMapWithoutHint(b *testing.B) {
    for i := 0; i < b.N; i++ {
        m := make(map[int]int)
        for j := 0; j < 1000; j++ {
            m[j] = j
        }
    }
}

// Результат:
// BenchmarkMapWithHint      30000   45000 ns/op   41000 B/op   2 allocs
// BenchmarkMapWithoutHint   20000   80000 ns/op   86000 B/op  12 allocs
```

## Особые случаи

### nil map

```go
var m map[string]int  // nil map

// ✅ Чтение работает (возвращает zero value)
v := m["key"]      // v = 0
v, ok := m["key"]  // v = 0, ok = false
len(m)             // 0

// ❌ Запись — panic!
m["key"] = 1  // panic: assignment to entry in nil map
```

### NaN как ключ

```go
import "math"

m := make(map[float64]string)
m[math.NaN()] = "first"
m[math.NaN()] = "second"

fmt.Println(len(m))  // 2! (NaN != NaN)
fmt.Println(m[math.NaN()])  // "" (не найдёт!)

// NaN'ы попадают в map, но их нельзя найти
```

### Пустая структура как значение (Set)

```go
// Эффективный Set (0 bytes на значение)
type Set map[string]struct{}

s := make(Set)
s["item"] = struct{}{}

if _, ok := s["item"]; ok {
    fmt.Println("exists")
}
```

## Вопросы с собеседований

### Вопрос 1: Как устроен map под капотом?

<details>
<summary>Ответ</summary>

Map — это хеш-таблица с массивом бакетов:
- `hmap` — заголовок с метаданными (count, B, buckets pointer)
- Бакеты — массив из 2^B элементов
- Каждый бакет хранит до 8 пар ключ-значение
- `tophash` — 8 байт для быстрой проверки хеша
- Overflow — указатель на следующий бакет при коллизиях

Ключи и значения хранятся в отдельных массивах для экономии памяти (меньше padding).

</details>

### Вопрос 2: Как происходит поиск элемента?

<details>
<summary>Ответ</summary>

1. Вычисляется hash(key) с seed h.hash0
2. Младшие B бит определяют номер бакета
3. Старшие 8 бит — tophash для быстрого сравнения
4. В бакете сначала сравниваем tophash (быстро)
5. Если совпал — сравниваем полный ключ
6. Если не нашли — идём в overflow bucket
7. Повторяем пока не найдём или не дойдём до конца

</details>

### Вопрос 3: Когда и как растёт map?

<details>
<summary>Ответ</summary>

**Когда:**
1. Load factor > 6.5 (count / buckets > 6.5) → удвоение
2. Слишком много overflow бакетов → same-size grow

**Как:**
- Создаётся новый массив бакетов (2x или 1x)
- Старый массив сохраняется в oldbuckets
- Элементы эвакуируются **постепенно** (1-2 бакета за операцию)
- После полной эвакуации oldbuckets освобождается

Инкрементальная эвакуация не блокирует операции.

</details>

### Вопрос 4: Почему нельзя взять адрес элемента map?

<details>
<summary>Ответ</summary>

При росте map элементы перемещаются в новые бакеты. Указатель на старое расположение стал бы невалидным (dangling pointer).

Это ошибка компиляции: `cannot take the address of m[key]`

Обходной путь — хранить указатели как значения: `map[K]*V`

</details>

### Вопрос 5: Почему порядок итерации случайный?

<details>
<summary>Ответ</summary>

1. **Защита от HashDoS** — злоумышленник не может предсказать порядок коллизий
2. **Предотвращение зависимости** — код не должен полагаться на порядок
3. **Реализация** — Go специально рандомизирует стартовую позицию итератора (используя hash0 как seed)

Стартовый бакет и позиция в бакете выбираются случайно при каждом range.

</details>

### Вопрос 6: Как сделать map потокобезопасным?

<details>
<summary>Ответ</summary>

Map НЕ потокобезопасен. Решения:

1. **sync.Mutex** — простой вариант
2. **sync.RWMutex** — если много чтений
3. **sync.Map** — встроенная thread-safe map (хороша для cache-like паттернов)
4. **Шардирование** — несколько map с отдельными mutex (для высокой нагрузки)

```go
var m sync.Map
m.Store("key", value)
v, _ := m.Load("key")
```

</details>

## Связанные темы

- [[Go - Карты (maps)]]
- [[Go - Внутреннее устройство slice]]
- [[HashMap - Реализация и особенности]]
- [[Go - Пакет sync]]
- [[Go - Race Condition и Data Race]]
