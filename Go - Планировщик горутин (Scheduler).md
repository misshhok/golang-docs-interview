# Go - Планировщик горутин (Scheduler)

Планировщик Go (Go Scheduler) — это компонент runtime, который управляет выполнением горутин. Понимание его работы критически важно для Senior Golang разработчика и часто спрашивается на собеседованиях.

## Зачем нужен свой планировщик?

Go не использует потоки ОС напрямую для каждой горутины, потому что:

| Характеристика | OS Thread | Goroutine |
|----------------|-----------|-----------|
| Память | 1-8 MB стек | 2 KB стек (растёт динамически) |
| Создание | ~1ms | ~1μs |
| Переключение контекста | ~1-10μs (kernel) | ~100-200ns (userspace) |
| Количество | Тысячи | Миллионы |

**Вывод:** Go планировщик позволяет эффективно мультиплексировать миллионы горутин на небольшое количество OS threads.

## GMP модель

Планировщик Go основан на модели **GMP**:

```
┌─────────────────────────────────────────────────────────────────┐
│                         Go Scheduler                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐              │
│   │  G  │ │  G  │ │  G  │ │  G  │ │  G  │ │  G  │  ... (много) │
│   └──┬──┘ └──┬──┘ └──┬──┘ └──┬──┘ └──┬──┘ └──┬──┘              │
│      │       │       │       │       │       │                  │
│      └───────┴───────┼───────┴───────┴───────┘                  │
│                      ▼                                           │
│              ┌───────────────┐      ┌───────────────┐           │
│              │       P       │      │       P       │           │
│              │  ┌─────────┐  │      │  ┌─────────┐  │           │
│              │  │   LRQ   │  │      │  │   LRQ   │  │           │
│              │  └─────────┘  │      │  └─────────┘  │           │
│              └───────┬───────┘      └───────┬───────┘           │
│                      │                      │                    │
│                      ▼                      ▼                    │
│              ┌───────────────┐      ┌───────────────┐           │
│              │       M       │      │       M       │           │
│              │  (OS Thread)  │      │  (OS Thread)  │           │
│              └───────────────┘      └───────────────┘           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### G (Goroutine)

Структура `g` содержит:

```go
type g struct {
    stack       stack   // стек горутины
    stackguard0 uintptr // для проверки переполнения стека
    m           *m      // текущий M, исполняющий эту G
    sched       gobuf   // контекст планирования (SP, PC, etc.)
    atomicstatus uint32 // статус: _Gidle, _Grunnable, _Grunning, _Gwaiting...
    goid        int64   // уникальный ID горутины
    // ... и другие поля
}
```

**Состояния горутины:**

```
         ┌──────────────────────────────────────────┐
         │                                          │
         ▼                                          │
    ┌─────────┐     go func()     ┌───────────┐    │
    │  _Gidle │ ─────────────────▶│ _Grunnable│────┤
    └─────────┘                   └─────┬─────┘    │
                                        │          │
                              schedule  │          │
                                        ▼          │
                                  ┌───────────┐    │
                            ┌────▶│ _Grunning │────┘
                            │     └─────┬─────┘
                            │           │
                    Gosched/│           │ chan/mutex/
                    preempt │           │ syscall/io
                            │           ▼
                            │     ┌───────────┐
                            └─────│ _Gwaiting │
                                  └───────────┘
                                        │
                                        │ ready
                                        ▼
                                  ┌───────────┐
                                  │  _Gdead   │
                                  └───────────┘
```

### M (Machine = OS Thread)

Структура `m` представляет OS thread:

```go
type m struct {
    g0      *g     // специальная горутина для планирования
    curg    *g     // текущая пользовательская горутина
    p       *p     // присоединённый P (или nil)
    spinning bool  // M ищет работу
    // ...
}
```

**Ключевые моменты:**
- M исполняет код горутин
- Каждый M имеет специальную `g0` для выполнения кода планировщика
- M может существовать без P (когда заблокирован в syscall)
- Количество M ограничено `GOMAXPROCS` (активных) + заблокированные в syscalls

### P (Processor = Логический процессор)

Структура `p` — контекст выполнения:

```go
type p struct {
    status    uint32     // _Pidle, _Prunning, _Psyscall...
    m         *m         // связанный M (или nil)
    runq      [256]guintptr // локальная очередь (LRQ), кольцевой буфер
    runqhead  uint32
    runqtail  uint32
    runnext   guintptr   // следующая G для запуска (приоритет)
    // ...
}
```

**Ключевые моменты:**
- Количество P = `GOMAXPROCS` (по умолчанию = кол-во CPU)
- P содержит ресурсы для выполнения Go кода (mcache, etc.)
- P необходим для исполнения горутин (M без P не может запускать G)

## Очереди горутин

### Local Run Queue (LRQ)

Каждый P имеет свою локальную очередь:

```
┌─────────────────────────────────────┐
│              P                       │
│  ┌─────────────────────────────┐    │
│  │  runnext: G7 (приоритетная) │    │
│  └─────────────────────────────┘    │
│  ┌─────────────────────────────┐    │
│  │  LRQ: [G1, G2, G3, G4, G5]  │    │  ← до 256 горутин
│  │       head ────────▶ tail   │    │
│  └─────────────────────────────┘    │
└─────────────────────────────────────┘
```

- **Размер:** 256 горутин (кольцевой буфер)
- **runnext:** Одна "быстрая" горутина с приоритетом (только что созданная или разблокированная)
- **Преимущество:** Доступ без глобальных блокировок

### Global Run Queue (GRQ)

```go
var sched struct {
    lock    mutex
    runq    gQueue  // глобальная очередь
    runqsize int32
    // ...
}
```

**Когда используется GRQ:**
1. LRQ переполнена (>256 горутин)
2. P забирает горутины, когда его LRQ пуста
3. Некоторые системные горутины помещаются сюда

### Алгоритм выбора следующей горутины

```go
func schedule() {
    // 1. Проверяем runnext (приоритетная горутина)
    if gp := _p_.runnext; gp != 0 {
        return gp
    }

    // 2. Берём из локальной очереди
    if gp := runqget(_p_); gp != nil {
        return gp
    }

    // 3. Каждые 61 тик проверяем глобальную очередь
    if _p_.schedtick%61 == 0 {
        if gp := globrunqget(_p_, 1); gp != nil {
            return gp
        }
    }

    // 4. Проверяем network poller
    if gp := netpoll(); gp != nil {
        return gp
    }

    // 5. Work stealing из других P
    if gp := stealWork(_p_); gp != nil {
        return gp
    }

    // 6. Проверяем глобальную очередь ещё раз
    if gp := globrunqget(_p_, 0); gp != nil {
        return gp
    }

    // 7. Ничего нет — M переходит в spinning или паркуется
}
```

## Work Stealing

Когда у P закончились горутины, он "ворует" работу у других P:

```
P1 (пустой)                    P2 (много работы)
┌───────────┐                 ┌───────────┐
│  LRQ: []  │    ──steal──▶   │ LRQ: [G1, G2, G3, G4, G5, G6] │
└───────────┘                 └───────────┘

                После steal:

P1                             P2
┌───────────┐                 ┌───────────┐
│ LRQ:[G4,G5,G6]│             │ LRQ:[G1,G2,G3] │
└───────────┘                 └───────────┘
```

**Алгоритм:**
1. Выбирается случайный P (victim)
2. Воруется **половина** горутин из его LRQ
3. Если не удалось — пробуем другой P
4. Если у всех пусто — проверяем GRQ и network poller

```go
func stealWork(p *p) *g {
    const stealTries = 4

    for i := 0; i < stealTries; i++ {
        // Выбираем случайного victim
        victim := allp[fastrand() % len(allp)]
        if victim == p {
            continue
        }

        // Воруем половину очереди
        if gp := runqsteal(p, victim, true); gp != nil {
            return gp
        }
    }
    return nil
}
```

## Preemption (Вытеснение)

### Кооперативная вытеснение (до Go 1.14)

Горутина отдаёт управление добровольно в определённых точках:
- Вызов функции (проверка `stackguard`)
- Операции с каналами
- Вызов `runtime.Gosched()`
- System calls

**Проблема:** Бесконечный цикл без вызова функций мог заблокировать P навсегда:

```go
// ❌ До Go 1.14 этот код мог заблокировать весь P
func badLoop() {
    for {
        // Чистые вычисления, нет вызова функций
        x = x + 1
    }
}
```

### Сигнальная (асинхронная) вытеснение (Go 1.14+)

```
┌─────────────────────────────────────────────────────┐
│                    Sysmon                            │
│                      │                               │
│           (каждые 10-20ms)                          │
│                      ▼                               │
│    ┌─────────────────────────────────────┐          │
│    │  Горутина работает > 10ms?          │          │
│    └──────────────────┬──────────────────┘          │
│                       │ да                           │
│                       ▼                              │
│    ┌─────────────────────────────────────┐          │
│    │  Отправить SIGURG сигнал на M       │          │
│    └──────────────────┬──────────────────┘          │
│                       │                              │
│                       ▼                              │
│    ┌─────────────────────────────────────┐          │
│    │  Signal handler сохраняет контекст  │          │
│    │  и переключает на другую горутину   │          │
│    └─────────────────────────────────────┘          │
└─────────────────────────────────────────────────────┘
```

**Механизм:**
1. `sysmon` обнаруживает, что горутина работает > 10ms
2. Устанавливает флаг `preempt` и отправляет `SIGURG`
3. Signal handler (asyncPreempt) прерывает выполнение
4. Горутина помещается обратно в очередь

```go
// Теперь этот код не заблокирует систему
func longLoop() {
    for {
        x = x + 1  // Будет прервано через ~10ms
    }
}
```

## Syscall Handling

Когда горутина делает системный вызов:

```
                    Syscall начинается
                           │
                           ▼
┌──────────────────────────────────────────────────────┐
│         M отсоединяет P (handoff)                    │
│                                                       │
│   ДО:                      ПОСЛЕ:                    │
│   ┌───┐ ─── ┌───┐         ┌───┐     ┌───┐           │
│   │ M │─────│ P │         │ M │     │ P │──┌───┐    │
│   └───┘     └───┘         └───┘     └───┘  │M' │    │
│     │         │             │              └───┘    │
│   ┌───┐     ┌───┐         ┌───┐                     │
│   │ G │     │LRQ│         │ G │  (в syscall)        │
│   └───┘     └───┘         └───┘                     │
│                                                       │
│   P передаётся другому M (или создаётся новый M')   │
└──────────────────────────────────────────────────────┘
```

**Алгоритм handoff:**
1. Перед блокирующим syscall: M отсоединяет P
2. P передаётся spinning M или создаётся новый M
3. После завершения syscall: M пытается получить P обратно
4. Если P занят — горутина помещается в GRQ

```go
// runtime/proc.go (упрощённо)
func entersyscall() {
    _g_ := getg()
    _p_ := _g_.m.p.ptr()

    // Сохраняем состояние
    save(...)

    // Отсоединяем P
    _p_.m = 0
    _g_.m.p = 0

    // P готов к handoff
    atomic.Store(&_p_.status, _Psyscall)
}

func exitsyscall() {
    _g_ := getg()

    // Пытаемся вернуть старый P
    if oldp := _g_.m.oldp; oldp != nil && oldp.status == _Psyscall {
        // Успех — продолжаем работу
        wirep(oldp)
        return
    }

    // Ищем любой свободный P
    if p := pidleget(); p != nil {
        wirep(p)
        return
    }

    // Нет свободных P — паркуем горутину в GRQ
    stopm()
    schedule()
}
```

## Network Poller

Go использует неблокирующий I/O с `epoll`/`kqueue`:

```
┌─────────────────────────────────────────────────────────┐
│                    Network Poller                        │
│                                                          │
│   Горутина делает conn.Read()                           │
│            │                                             │
│            ▼                                             │
│   ┌─────────────────────┐                               │
│   │ Данные готовы?      │───да──▶ Возврат данных       │
│   └──────────┬──────────┘                               │
│              │ нет                                       │
│              ▼                                           │
│   ┌─────────────────────┐                               │
│   │ Регистрируем FD в   │                               │
│   │ epoll/kqueue        │                               │
│   └──────────┬──────────┘                               │
│              │                                           │
│              ▼                                           │
│   ┌─────────────────────┐                               │
│   │ Горутина паркуется  │                               │
│   │ (не занимает M!)    │                               │
│   └──────────┬──────────┘                               │
│              │                                           │
│      ... время проходит ...                             │
│              │                                           │
│              ▼                                           │
│   ┌─────────────────────┐                               │
│   │ epoll_wait возвращает│                              │
│   │ что FD готов        │                               │
│   └──────────┬──────────┘                               │
│              │                                           │
│              ▼                                           │
│   ┌─────────────────────┐                               │
│   │ Горутина становится │                               │
│   │ runnable            │                               │
│   └─────────────────────┘                               │
└─────────────────────────────────────────────────────────┘
```

**Ключевое преимущество:** Заблокированная на I/O горутина **не занимает M**!

```go
// Внутри netpoll (упрощённо)
func netpoll(delay int64) gList {
    // Ждём события на epoll/kqueue
    n := epollwait(epfd, events, delay)

    var toSchedule gList
    for i := 0; i < n; i++ {
        pd := events[i].data

        // Находим припаркованную горутину
        if pd.rg != 0 {
            toSchedule.push(pd.rg)
        }
    }

    return toSchedule
}
```

## Sysmon

`sysmon` — специальная системная горутина, работающая в фоне:

```go
func sysmon() {
    for {
        // 1. Вытеснение долго работающих горутин
        retake(now)

        // 2. Освобождение неиспользуемых P из syscall
        for _, p := range allp {
            if p.status == _Psyscall && now-p.syscalltime > 10ms {
                handoffp(p)
            }
        }

        // 3. Проверка network poller
        if netpollinited() {
            gp := netpoll(0)
            injectglist(gp) // добавляем в очереди
        }

        // 4. Принудительный GC если нужно
        if gcTrigger.test() {
            forcegc()
        }

        sleep(interval) // 20μs → 10ms (адаптивно)
    }
}
```

**Функции sysmon:**
1. Preemption долго работающих горутин (>10ms)
2. Handoff P от заблокированных в syscall M
3. Опрос network poller
4. Запуск GC при необходимости
5. Scavenging памяти

## Spinning Threads

"Spinning" M — это M который активно ищет работу вместо того чтобы припарковаться:

```
┌───────────────────────────────────────────────────────┐
│  Почему spinning полезен?                             │
│                                                        │
│  БЕЗ spinning:                                        │
│  1. M1 заканчивает работу                             │
│  2. M1 паркуется (syscall в ядро)                     │
│  3. Новая G появляется                                │
│  4. Нужно разбудить M1 (syscall в ядро)               │
│  = 2 дорогих syscall'а                                │
│                                                        │
│  СО spinning:                                         │
│  1. M1 заканчивает работу                             │
│  2. M1 крутится (spinning), проверяет очереди        │
│  3. Новая G появляется                                │
│  4. M1 сразу берёт её                                 │
│  = 0 syscall'ов                                       │
└───────────────────────────────────────────────────────┘
```

**Правила spinning:**
- Максимум `GOMAXPROCS` spinning M
- M крутится ограниченное время, потом паркуется
- Обеспечивает низкую latency для новых горутин

## Рост стека горутины

Стек горутины начинается с 2KB и растёт по необходимости:

```
Начальный стек: 2KB
        │
        ▼
┌──────────────────────┐
│      Stack           │ ← stackguard
│   ┌──────────────┐   │
│   │   2 KB       │   │
│   └──────────────┘   │
└──────────────────────┘

После роста (copystack):
        │
        ▼
┌──────────────────────┐
│      Stack           │
│   ┌──────────────┐   │
│   │    4 KB      │   │ ← Скопированы данные
│   └──────────────┘   │
└──────────────────────┘
```

**Механизм:**
1. При каждом вызове функции проверяется `stackguard`
2. Если места мало — вызывается `morestack`
3. Выделяется новый стек (2x размера)
4. Данные копируются, указатели корректируются
5. Старый стек освобождается

```go
// Псевдокод проверки стека в начале каждой функции
func someFunction() {
    if SP < stackguard {
        morestack() // Увеличить стек
    }
    // ... код функции
}
```

## Практический пример: runtime.Gosched()

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    runtime.GOMAXPROCS(1) // Один P для наглядности

    go func() {
        for i := 0; i < 5; i++ {
            fmt.Println("Goroutine:", i)
            runtime.Gosched() // Явно отдаём управление планировщику
        }
    }()

    for i := 0; i < 5; i++ {
        fmt.Println("Main:", i)
        runtime.Gosched()
    }
}

// Вывод (чередование):
// Main: 0
// Goroutine: 0
// Main: 1
// Goroutine: 1
// ...
```

## Вопросы с собеседований

### Вопрос 1: Что такое GMP модель?

<details>
<summary>Ответ</summary>

**G (Goroutine)** — горутина, содержит стек, instruction pointer, статус.

**M (Machine)** — OS thread, исполняет код горутин. M может существовать без P (в syscall).

**P (Processor)** — логический процессор, контекст для выполнения. Содержит LRQ (локальную очередь горутин). Количество P = GOMAXPROCS.

Для выполнения горутины нужна связка: G привязана к M, M привязан к P.
</details>

### Вопрос 2: Что такое Work Stealing и зачем он нужен?

<details>
<summary>Ответ</summary>

Work Stealing — механизм балансировки нагрузки. Когда у P заканчиваются горутины в LRQ, он "ворует" половину горутин из очереди другого случайного P.

**Зачем нужен:**
- Балансировка нагрузки между P
- Избежание ситуации когда один P перегружен, а другие простаивают
- Эффективное использование всех CPU
</details>

### Вопрос 3: Как работает preemption в Go? Чем отличается Go 1.14+?

<details>
<summary>Ответ</summary>

**До Go 1.14 (кооперативная):**
- Горутина отдавала управление только в определённых точках (вызов функции, channel op, Gosched)
- Бесконечный цикл без вызовов функций мог заблокировать P

**Go 1.14+ (сигнальная/асинхронная):**
- sysmon отслеживает горутины, работающие > 10ms
- Отправляет сигнал SIGURG
- Signal handler прерывает горутину и возвращает управление планировщику
- Любой код теперь может быть вытеснен
</details>

### Вопрос 4: Что происходит когда горутина делает системный вызов?

<details>
<summary>Ответ</summary>

1. M отсоединяет P перед входом в syscall (handoff)
2. P передаётся другому (spinning) M или создаётся новый M
3. Исходный M блокируется в syscall вместе с G
4. После завершения syscall M пытается получить P:
   - Если старый P свободен — забирает его
   - Иначе ищет любой свободный P
   - Если нет свободных — горутина помещается в GRQ, M паркуется
</details>

### Вопрос 5: Почему сетевой I/O не блокирует M?

<details>
<summary>Ответ</summary>

Go использует неблокирующий I/O через Network Poller (epoll/kqueue):

1. Горутина пытается читать из сокета
2. Если данных нет — FD регистрируется в epoll
3. Горутина паркуется (но M освобождается!)
4. sysmon периодически опрашивает netpoll
5. Когда данные готовы — горутина становится runnable

В отличие от syscall, M не блокируется — он может выполнять другие горутины.
</details>

### Вопрос 6: Что такое spinning threads?

<details>
<summary>Ответ</summary>

Spinning M — это M без работы, который активно ищет горутины вместо того чтобы припарковаться.

**Преимущества:**
- Новые горутины подхватываются мгновенно (не нужен syscall для пробуждения M)
- Снижает latency

**Ограничения:**
- Максимум GOMAXPROCS spinning M
- После некоторого времени M паркуется (экономия CPU)
</details>

### Вопрос 7: Как растёт стек горутины?

<details>
<summary>Ответ</summary>

1. Начальный размер стека — 2KB
2. При каждом вызове функции проверяется stackguard
3. Если места мало — вызывается morestack:
   - Выделяется новый стек (2x размера)
   - Данные копируются (copystack)
   - Указатели корректируются
   - Старый стек освобождается
4. Стек может вырасти до 1GB (по умолчанию)

Это называется "contiguous stacks" (с Go 1.3).
</details>

## Полезные команды для отладки

```bash
# Трассировка планировщика
GODEBUG=schedtrace=1000 ./myprogram  # каждую секунду

# Детальная трассировка
GODEBUG=scheddetail=1,schedtrace=1000 ./myprogram

# Пример вывода:
# SCHED 1000ms: gomaxprocs=4 idleprocs=2 threads=5 spinningthreads=1
#               idlethreads=2 runqueue=0 [3 2 0 1]
#
# gomaxprocs  — GOMAXPROCS
# idleprocs   — свободные P
# threads     — всего M
# runqueue    — размер GRQ
# [3 2 0 1]   — размеры LRQ каждого P
```

## Связанные темы

- [[Go - Горутины (goroutines)]]
- [[Go - Каналы (channels)]]
- [[Go - Context]]
- [[Go - Атомарные операции]]
- [[Go - Профилирование (pprof)]]
- [[Многопоточность vs Параллелизм vs Конкурентность]]
- [[Go - Race Condition и Data Race]]
