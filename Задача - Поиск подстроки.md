# Задача - Поиск подстроки

Найти первое вхождение подстроки (needle) в строке (haystack).

## Условие

Реализовать функцию `strStr()` (аналог `strings.Index()` в Go).

```
Input:  haystack = "hello", needle = "ll"
Output: 2

Input:  haystack = "aaaaa", needle = "bba"
Output: -1
```

**Требования:**
- Вернуть индекс первого вхождения needle в haystack
- Вернуть -1, если needle не найден
- Если needle пустая строка, вернуть 0

## Подход 1: Наивный алгоритм

**Идея:** Проверить каждую позицию в haystack.

```go
func strStr(haystack string, needle string) int {
    if needle == "" {
        return 0
    }

    n, m := len(haystack), len(needle)

    if m > n {
        return -1
    }

    // Проверить каждую позицию
    for i := 0; i <= n-m; i++ {
        // Проверить совпадение с этой позиции
        match := true
        for j := 0; j < m; j++ {
            if haystack[i+j] != needle[j] {
                match = false
                break
            }
        }

        if match {
            return i
        }
    }

    return -1
}
```

**Сложность:**
- Время: O(n × m) worst case
- Память: O(1)

**Когда плохо:** `haystack = "aaaaaaaaab"`, `needle = "aaab"`

```
Попытка 1: aaaa... (несовпадение на позиции 3)
Попытка 2: aaaa... (несовпадение на позиции 3)
...
Много ненужных сравнений!
```

## Подход 2: KMP (Knuth-Morris-Pratt)

**Идея:** Используем префикс-функцию, чтобы пропускать уже проверенные символы.

```go
func strStrKMP(haystack string, needle string) int {
    if needle == "" {
        return 0
    }

    n, m := len(haystack), len(needle)

    if m > n {
        return -1
    }

    // Построить LPS (Longest Proper Prefix which is also Suffix)
    lps := computeLPS(needle)

    i, j := 0, 0  // i для haystack, j для needle

    for i < n {
        if haystack[i] == needle[j] {
            i++
            j++
        }

        if j == m {
            return i - j  // Найдено!
        } else if i < n && haystack[i] != needle[j] {
            if j != 0 {
                j = lps[j-1]  // Не начинаем с начала!
            } else {
                i++
            }
        }
    }

    return -1
}

func computeLPS(pattern string) []int {
    m := len(pattern)
    lps := make([]int, m)
    length := 0  // Длина предыдущего longest prefix suffix
    i := 1

    for i < m {
        if pattern[i] == pattern[length] {
            length++
            lps[i] = length
            i++
        } else {
            if length != 0 {
                length = lps[length-1]
            } else {
                lps[i] = 0
                i++
            }
        }
    }

    return lps
}
```

**Сложность:**
- Время: O(n + m)
- Память: O(m) для LPS массива

### Как работает LPS?

```
pattern = "AAACAAAA"

LPS массив:
A  A  A  C  A  A  A  A
0  1  2  0  1  2  3  3

lps[7] = 3 означает:
"AAA" - префикс длины 3
"AAA" - суффикс длины 3
Они совпадают!
```

**Зачем это нужно?**

```
haystack: A A A A A A A C
pattern:  A A A C

Позиция 0-2: совпадают (AAA)
Позиция 3: не совпадает (A != C)

Наивный: начать заново с позиции 1
KMP: lps[2] = 2, значит первые 2 символа уже совпадают!
     Продолжаем с позиции 2 в pattern
```

### Визуализация KMP

```
haystack: "ABABCABABA"
needle:   "ABABCABAA"
lps:      [0,0,1,2,0,1,2,3,1]

Step 1: Сравниваем ABABC (совпадают)
haystack: A B A B C A B A B A
needle:   A B A B C
          ↑ ↑ ↑ ↑ ↑
i=0-4, j=0-4 (все совпадают)

Step 2: haystack[5]='A', needle[5]='A' (совпадают)
haystack: A B A B C A B A B A
needle:   A B A B C A
                    ↑
i=5, j=5 (совпадают)

Step 3: haystack[6]='B', needle[6]='B' (совпадают)
i=6, j=6

Step 4: haystack[7]='A', needle[7]='A' (совпадают)
i=7, j=7

Step 5: haystack[8]='B', needle[8]='A' (НЕ совпадают!)
Используем lps[7]=1, откатываем j на позицию 1
needle:       A B A B C A B A A
                        ↑
Продолжаем с j=1
```

## Подход 3: Rabin-Karp (Rolling Hash)

**Идея:** Сравниваем хеши вместо символов.

```go
const prime = 101

func strStrRabinKarp(haystack string, needle string) int {
    if needle == "" {
        return 0
    }

    n, m := len(haystack), len(needle)

    if m > n {
        return -1
    }

    // Вычислить хеши
    needleHash := hash(needle)
    windowHash := hash(haystack[:m])

    for i := 0; i <= n-m; i++ {
        // Сравнить хеши
        if windowHash == needleHash {
            // Проверить точное совпадение (избежать коллизий)
            if haystack[i:i+m] == needle {
                return i
            }
        }

        // Rolling hash для следующего окна
        if i < n-m {
            windowHash = rollingHash(
                windowHash,
                haystack[i],
                haystack[i+m],
                m,
            )
        }
    }

    return -1
}

func hash(s string) int {
    h := 0
    for i := 0; i < len(s); i++ {
        h += int(s[i]) * pow(prime, len(s)-i-1)
    }
    return h
}

func rollingHash(oldHash int, oldChar, newChar byte, m int) int {
    // Убрать вклад старого символа
    oldHash -= int(oldChar) * pow(prime, m-1)

    // Сдвинуть влево
    oldHash *= prime

    // Добавить новый символ
    oldHash += int(newChar)

    return oldHash
}

func pow(base, exp int) int {
    result := 1
    for i := 0; i < exp; i++ {
        result *= base
    }
    return result
}
```

**Сложность:**
- Время: O(n + m) average, O(n × m) worst (при коллизиях)
- Память: O(1)

**Преимущество:** Хорошо для поиска нескольких паттернов.

### Rolling Hash визуализация

```
haystack: "abcde"
needle:   "cde"

Hash функция: h = c[0]×101² + c[1]×101¹ + c[2]×101⁰

Окно 1 "abc":
hash = 'a'×101² + 'b'×101 + 'c' = 97×10201 + 98×101 + 99 = 999696

Окно 2 "bcd":
Старый способ: пересчитать с нуля
Rolling hash:
  1. Убрать 'a': hash -= 97×101² = hash - 989497
  2. Умножить на 101: hash *= 101
  3. Добавить 'd': hash += 100

Результат за O(1)!
```

## Подход 4: Встроенная функция Go

```go
import "strings"

func strStr(haystack string, needle string) int {
    return strings.Index(haystack, needle)
}
```

В Go `strings.Index` использует оптимизированный алгоритм (модифицированный Boyer-Moore).

## Сравнение алгоритмов

| Алгоритм | Время (worst) | Время (avg) | Память | Сложность реализации |
|----------|---------------|-------------|--------|---------------------|
| Наивный | O(n×m) | O(n×m) | O(1) | Простая |
| KMP | O(n+m) | O(n+m) | O(m) | Средняя |
| Rabin-Karp | O(n×m) | O(n+m) | O(1) | Средняя |
| Boyer-Moore | O(n×m) | O(n/m) | O(m) | Сложная |

## Follow-up вопросы

### 1. Найти все вхождения

```go
func findAllOccurrences(haystack, needle string) []int {
    if needle == "" {
        return []int{}
    }

    n, m := len(haystack), len(needle)
    result := []int{}

    for i := 0; i <= n-m; i++ {
        if haystack[i:i+m] == needle {
            result = append(result, i)
        }
    }

    return result
}

// Или использовать strings
import "strings"

func findAllOccurrences(haystack, needle string) []int {
    result := []int{}
    start := 0

    for {
        idx := strings.Index(haystack[start:], needle)
        if idx == -1 {
            break
        }

        result = append(result, start+idx)
        start += idx + 1
    }

    return result
}
```

### 2. Case-insensitive поиск

```go
import "strings"

func strStrCaseInsensitive(haystack, needle string) int {
    return strings.Index(
        strings.ToLower(haystack),
        strings.ToLower(needle),
    )
}
```

### 3. Поиск с wildcard

```
"ab?de" соответствует "abcde", "abxde", и т.д.
```

```go
func matchWildcard(haystack, pattern string) bool {
    n, m := len(haystack), len(pattern)

    dp := make([][]bool, n+1)
    for i := range dp {
        dp[i] = make([]bool, m+1)
    }

    dp[0][0] = true

    for i := 0; i <= n; i++ {
        for j := 1; j <= m; j++ {
            if pattern[j-1] == '?' {
                if i > 0 {
                    dp[i][j] = dp[i-1][j-1]
                }
            } else if pattern[j-1] == '*' {
                dp[i][j] = dp[i][j-1]
                if i > 0 {
                    dp[i][j] = dp[i][j] || dp[i-1][j]
                }
            } else {
                if i > 0 && haystack[i-1] == pattern[j-1] {
                    dp[i][j] = dp[i-1][j-1]
                }
            }
        }
    }

    return dp[n][m]
}
```

## Типичные ошибки

### Ошибка 1: Выход за границы

```go
// ❌ Неправильно
for i := 0; i < n; i++ {  // Должно быть i <= n-m
    if haystack[i:i+m] == needle {  // Panic!
        return i
    }
}

// ✅ Правильно
for i := 0; i <= n-m; i++ {
    if haystack[i:i+m] == needle {
        return i
    }
}
```

### Ошибка 2: Забыли проверить пустую строку

```go
// ❌ Неправильно
func strStr(haystack string, needle string) int {
    // Нет проверки needle == ""
    // ...
}

// ✅ Правильно
func strStr(haystack string, needle string) int {
    if needle == "" {
        return 0  // По стандарту
    }
    // ...
}
```

### Ошибка 3: UTF-8 и руны

```go
// ❌ Неправильно для UTF-8
haystack := "привет"
needle := "при"
// len(haystack) = 12 байт, не 6 символов!

// ✅ Правильно
runes := []rune(haystack)
// Работаем с рунами
```

## Оптимизации

### Ранний выход

```go
func strStr(haystack string, needle string) int {
    if needle == "" {
        return 0
    }

    n, m := len(haystack), len(needle)

    if m > n {
        return -1  // Ранний выход
    }

    // Сравнить первый и последний символы сначала
    first := needle[0]
    last := needle[m-1]

    for i := 0; i <= n-m; i++ {
        if haystack[i] != first {
            continue  // Пропустить
        }

        if haystack[i+m-1] != last {
            continue  // Пропустить
        }

        // Полная проверка
        if haystack[i:i+m] == needle {
            return i
        }
    }

    return -1
}
```

## Вопросы на собеседовании

**Яндекс:**
"Объясните, как работает KMP и зачем нужен LPS массив."

**VK Tech:**
"Какой алгоритм выбрать для поиска 1000 разных паттернов в большом тексте?"

**Ответ:** Aho-Corasick (множественный поиск) или построить суффиксное дерево.

**Озон:**
"Как найти все вхождения подстроки эффективно?"

**Ответ:** KMP или встроенный strings.Index в цикле.

**T-Bank:**
"Что будет, если haystack очень большой (1GB), а needle маленький (10 байт)?"

**Ответ:** Rabin-Karp или KMP. Можно читать haystack чанками с диска.

## Применение в реальности

### URL Matching

```go
func matchRoute(url, pattern string) bool {
    return strings.Index(url, pattern) != -1
}
```

### Log Search

```go
func searchLogs(logFile, keyword string) []string {
    file, _ := os.Open(logFile)
    defer file.Close()

    scanner := bufio.NewScanner(file)
    results := []string{}

    for scanner.Scan() {
        line := scanner.Text()
        if strings.Contains(line, keyword) {
            results = append(results, line)
        }
    }

    return results
}
```

### String Replace

```go
func replaceAll(s, old, new string) string {
    result := ""
    start := 0

    for {
        idx := strings.Index(s[start:], old)
        if idx == -1 {
            result += s[start:]
            break
        }

        result += s[start:start+idx] + new
        start += idx + len(old)
    }

    return result
}
```

## Тестовые случаи

```go
func main() {
    // Тест 1: Обычный случай
    fmt.Println(strStr("hello", "ll"))  // 2

    // Тест 2: Не найдено
    fmt.Println(strStr("aaaaa", "bba"))  // -1

    // Тест 3: Пустой needle
    fmt.Println(strStr("hello", ""))  // 0

    // Тест 4: needle == haystack
    fmt.Println(strStr("abc", "abc"))  // 0

    // Тест 5: needle длиннее haystack
    fmt.Println(strStr("ab", "abc"))  // -1

    // Тест 6: В начале
    fmt.Println(strStr("hello", "he"))  // 0

    // Тест 7: В конце
    fmt.Println(strStr("hello", "lo"))  // 3

    // Тест 8: Повторяющиеся символы
    fmt.Println(strStr("aaaaaab", "aaab"))  // 3
}
```

## Best Practices

1. ✅ Используйте `strings.Index()` для production кода
2. ✅ KMP для собеседований (показывает знание алгоритмов)
3. ✅ Rabin-Karp для множественного поиска
4. ✅ Проверяйте граничные случаи (пустые строки, длины)
5. ❌ Не забывайте про UTF-8 (используйте руны)
6. ❌ Избегайте substring операций в hot path (O(n) копирование)

## Связанные темы

- [[Алгоритмы на строках]]
- [[Go - Строки и UTF-8]]
- [[Скользящее окно (Sliding Window)]]
- [[Алгоритмическая сложность (Big O)]]
- [[Trie]]
- [[HashMap - Реализация и особенности]]
