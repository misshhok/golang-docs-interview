# Переменные среды и .env

Переменные среды (environment variables) — это механизм передачи конфигурации в приложение без изменения кода. Это один из принципов 12-factor app, который гласит: конфигурация должна храниться в окружении, а не в коде.

## Зачем нужны переменные среды

1. **Разделение конфигурации и кода** — один и тот же код работает в разных окружениях
2. **Безопасность** — секреты не попадают в git
3. **Гибкость** — легко изменить конфигурацию без пересборки
4. **Соответствие best practices** — 12-factor app methodology

## Переменные среды в Go

### os.Getenv

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // Чтение переменной среды
    dbHost := os.Getenv("DB_HOST")
    if dbHost == "" {
        dbHost = "localhost" // значение по умолчанию
    }

    dbPort := os.Getenv("DB_PORT")
    if dbPort == "" {
        dbPort = "5432"
    }

    fmt.Printf("Database: %s:%s\n", dbHost, dbPort)
}
```

### os.LookupEnv

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // LookupEnv позволяет отличить пустую строку от отсутствия переменной
    dbHost, exists := os.LookupEnv("DB_HOST")
    if !exists {
        fmt.Println("DB_HOST is not set")
        return
    }

    if dbHost == "" {
        fmt.Println("DB_HOST is set but empty")
    } else {
        fmt.Printf("DB_HOST: %s\n", dbHost)
    }
}
```

### os.Setenv (для тестов)

```go
package main

import (
    "os"
    "testing"
)

func TestDatabaseConnection(t *testing.T) {
    // Устанавливаем переменные для теста
    os.Setenv("DB_HOST", "localhost")
    os.Setenv("DB_PORT", "5432")

    defer func() {
        // Очищаем после теста
        os.Unsetenv("DB_HOST")
        os.Unsetenv("DB_PORT")
    }()

    // Тестируем функционал
    conn := NewDatabaseConnection()
    if conn.Host != "localhost" {
        t.Errorf("Expected localhost, got %s", conn.Host)
    }
}
```

## Файлы .env

### Формат .env файла

```bash
# .env файл
# Комментарий

# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=myapp
DB_USER=postgres
DB_PASSWORD=secret123

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# API
API_PORT=8080
API_TIMEOUT=30s

# JWT
JWT_SECRET=your-secret-key-here
JWT_EXPIRATION=24h

# External services
PAYMENT_API_KEY=pk_live_xxxxxxxxxxxxx
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
```

### Правила для .env файлов

1. ✅ **Добавь `.env` в `.gitignore`** — никогда не коммить секреты!
2. ✅ **Создай `.env.example`** — шаблон для других разработчиков
3. ✅ **Используй SCREAMING_SNAKE_CASE** для названий переменных
4. ✅ **Группируй переменные** по сервисам
5. ✅ **Документируй** переменные комментариями

### Пример .env.example

```bash
# .env.example
# Copy this file to .env and fill in your values

# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_NAME=your_database_name
DB_USER=your_database_user
DB_PASSWORD=your_database_password

# Redis Configuration
REDIS_HOST=localhost
REDIS_PORT=6379

# Application Configuration
API_PORT=8080
LOG_LEVEL=info

# JWT Configuration
JWT_SECRET=your-secret-key-change-me
JWT_EXPIRATION=24h
```

## godotenv библиотека

### Установка

```bash
go get github.com/joho/godotenv
```

### Базовое использование

```go
package main

import (
    "fmt"
    "log"
    "os"

    "github.com/joho/godotenv"
)

func main() {
    // Загружаем .env файл
    err := godotenv.Load()
    if err != nil {
        log.Fatal("Error loading .env file")
    }

    // Теперь можем читать переменные
    dbHost := os.Getenv("DB_HOST")
    dbPort := os.Getenv("DB_PORT")

    fmt.Printf("Database: %s:%s\n", dbHost, dbPort)
}
```

### Загрузка нескольких файлов

```go
package main

import (
    "github.com/joho/godotenv"
)

func main() {
    // Загружаем файлы в порядке приоритета
    // Переменные из первого файла имеют приоритет
    err := godotenv.Load(".env.local", ".env")
    if err != nil {
        log.Fatal("Error loading .env files")
    }
}
```

### Загрузка в зависимости от окружения

```go
package main

import (
    "fmt"
    "github.com/joho/godotenv"
    "os"
)

func main() {
    env := os.Getenv("APP_ENV")
    if env == "" {
        env = "development"
    }

    // Загружаем файл для конкретного окружения
    envFile := fmt.Sprintf(".env.%s", env)

    // Сначала пробуем загрузить специфичный файл
    if err := godotenv.Load(envFile); err != nil {
        // Если не найден, загружаем .env по умолчанию
        godotenv.Load()
    }

    fmt.Printf("Running in %s environment\n", env)
}
```

## Структура для конфигурации

### Типизированная конфигурация

```go
package config

import (
    "fmt"
    "os"
    "strconv"
    "time"

    "github.com/joho/godotenv"
)

// Config содержит всю конфигурацию приложения
type Config struct {
    Database DatabaseConfig
    Redis    RedisConfig
    API      APIConfig
    JWT      JWTConfig
}

type DatabaseConfig struct {
    Host     string
    Port     int
    Name     string
    User     string
    Password string
}

type RedisConfig struct {
    Host string
    Port int
}

type APIConfig struct {
    Port    int
    Timeout time.Duration
}

type JWTConfig struct {
    Secret     string
    Expiration time.Duration
}

// Load загружает конфигурацию из переменных среды
func Load() (*Config, error) {
    // Загружаем .env файл (игнорируем ошибку в продакшене)
    godotenv.Load()

    cfg := &Config{}

    // Database
    cfg.Database.Host = getEnv("DB_HOST", "localhost")
    cfg.Database.Port = getEnvAsInt("DB_PORT", 5432)
    cfg.Database.Name = getEnv("DB_NAME", "myapp")
    cfg.Database.User = getEnv("DB_USER", "postgres")
    cfg.Database.Password = getEnv("DB_PASSWORD", "")

    // Redis
    cfg.Redis.Host = getEnv("REDIS_HOST", "localhost")
    cfg.Redis.Port = getEnvAsInt("REDIS_PORT", 6379)

    // API
    cfg.API.Port = getEnvAsInt("API_PORT", 8080)
    timeout := getEnv("API_TIMEOUT", "30s")
    duration, err := time.ParseDuration(timeout)
    if err != nil {
        return nil, fmt.Errorf("invalid API_TIMEOUT: %w", err)
    }
    cfg.API.Timeout = duration

    // JWT
    cfg.JWT.Secret = getEnv("JWT_SECRET", "")
    if cfg.JWT.Secret == "" {
        return nil, fmt.Errorf("JWT_SECRET is required")
    }
    jwtExp := getEnv("JWT_EXPIRATION", "24h")
    expDuration, err := time.ParseDuration(jwtExp)
    if err != nil {
        return nil, fmt.Errorf("invalid JWT_EXPIRATION: %w", err)
    }
    cfg.JWT.Expiration = expDuration

    return cfg, nil
}

// Вспомогательные функции
func getEnv(key, defaultValue string) string {
    value := os.Getenv(key)
    if value == "" {
        return defaultValue
    }
    return value
}

func getEnvAsInt(key string, defaultValue int) int {
    valueStr := os.Getenv(key)
    if valueStr == "" {
        return defaultValue
    }
    value, err := strconv.Atoi(valueStr)
    if err != nil {
        return defaultValue
    }
    return value
}
```

### Использование типизированной конфигурации

```go
package main

import (
    "fmt"
    "log"

    "myapp/config"
)

func main() {
    // Загружаем конфигурацию
    cfg, err := config.Load()
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }

    // Используем типизированные поля
    fmt.Printf("Database: %s:%d\n", cfg.Database.Host, cfg.Database.Port)
    fmt.Printf("API Port: %d\n", cfg.API.Port)
    fmt.Printf("JWT Expiration: %s\n", cfg.JWT.Expiration)

    // Передаем конфигурацию в другие части приложения
    db := connectDatabase(cfg.Database)
    cache := connectRedis(cfg.Redis)
    server := startServer(cfg.API, db, cache)
}
```

## 12-Factor App

### Принципы конфигурации

**III. Config** — храните конфигурацию в переменных среды:

✅ **Правильно:**
```go
// Конфигурация через переменные среды
dbHost := os.Getenv("DB_HOST")
apiKey := os.Getenv("API_KEY")
```

❌ **Неправильно:**
```go
// Хардкод конфигурации
const dbHost = "prod-db.example.com"
const apiKey = "sk_live_xxxxxxxxxxxxx"
```

### Разделение по окружениям

```bash
# .env.development
DB_HOST=localhost
API_URL=http://localhost:8080
LOG_LEVEL=debug

# .env.staging
DB_HOST=staging-db.example.com
API_URL=https://staging.example.com
LOG_LEVEL=info

# .env.production
DB_HOST=prod-db.example.com
API_URL=https://api.example.com
LOG_LEVEL=warn
```

## Docker и переменные среды

### В Dockerfile

```dockerfile
FROM golang:1.21-alpine

WORKDIR /app

COPY . .

RUN go build -o main .

# Переменные по умолчанию
ENV APP_ENV=production
ENV API_PORT=8080

CMD ["./main"]
```

### В docker-compose.yml

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=myapp
      - DB_USER=postgres
      - DB_PASSWORD=secret
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    env_file:
      - .env
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=secret
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```

## Безопасность

### Что НИКОГДА не коммитить

❌ `.env` — рабочие секреты
❌ `.env.production` — продакшн конфигурация
❌ `config.json` с секретами
❌ Приватные ключи и сертификаты

### Что можно коммитить

✅ `.env.example` — шаблон без реальных значений
✅ `.env.test` — конфигурация для тестов (если без секретов)

### .gitignore

```bash
# Environment variables
.env
.env.local
.env.*.local
.env.production

# Но не игнорируем примеры
!.env.example
```

## Типичные ошибки

### Ошибка 1: Хардкод секретов

```go
// ❌ Неправильно
const jwtSecret = "my-super-secret-key"
const dbPassword = "postgres123"

// ✅ Правильно
jwtSecret := os.Getenv("JWT_SECRET")
dbPassword := os.Getenv("DB_PASSWORD")
```

### Ошибка 2: Отсутствие значений по умолчанию

```go
// ❌ Неправильно - может быть пустая строка
port := os.Getenv("API_PORT")

// ✅ Правильно - есть fallback
port := os.Getenv("API_PORT")
if port == "" {
    port = "8080"
}
```

### Ошибка 3: Игнорирование ошибок парсинга

```go
// ❌ Неправильно
timeout, _ := time.ParseDuration(os.Getenv("TIMEOUT"))

// ✅ Правильно
timeoutStr := os.Getenv("TIMEOUT")
timeout, err := time.ParseDuration(timeoutStr)
if err != nil {
    log.Fatalf("Invalid TIMEOUT value: %v", err)
}
```

## Best Practices

1. ✅ **Используйте .env локально**, переменные среды в продакшене
2. ✅ **Валидируйте конфигурацию** при старте приложения
3. ✅ **Документируйте переменные** в .env.example
4. ✅ **Группируйте по сервисам** (DB_, REDIS_, API_)
5. ✅ **Используйте типизированную конфигурацию** вместо прямых вызовов os.Getenv
6. ✅ **Добавляйте значения по умолчанию** где возможно
7. ❌ **Не коммитьте .env** в git
8. ❌ **Не храните секреты** в коде или config файлах

## Вопросы с собеседований

**Вопрос:** Чем отличается os.Getenv от os.LookupEnv?

**Ответ:**
- `os.Getenv("KEY")` возвращает пустую строку, если переменная не установлена
- `os.LookupEnv("KEY")` возвращает значение и булев флаг существования, что позволяет отличить пустую строку от отсутствия переменной

**Вопрос:** Где хранить секреты в production?

**Ответ:** В продакшене используйте:
- Kubernetes Secrets
- AWS Secrets Manager / Systems Manager Parameter Store
- HashiCorp Vault
- Google Cloud Secret Manager
- Azure Key Vault

Никогда не храните секреты в .env файлах в продакшене!

**Вопрос:** Что такое 12-factor app?

**Ответ:** Это методология разработки облачных приложений. Один из принципов (Config) гласит: конфигурация должна строго отделяться от кода и храниться в переменных среды. Это позволяет использовать один и тот же код в разных окружениях.

## Связанные темы

- [[Go - Пакеты и модули]]
- [[Docker - Docker Compose]]
- [[Kubernetes - ConfigMaps и Secrets]]
- [[Bash - Основы скриптинга]]
- [[CI-CD - Основные концепции]]
