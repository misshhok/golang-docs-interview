# Микросервисная архитектура

Микросервисная архитектура — это подход к разработке приложения как набора небольших, независимых сервисов, каждый из которых работает в своем процессе и взаимодействует через легковесные механизмы (обычно HTTP API или message queues).

## Основные принципы

### 1. Независимость сервисов

Каждый микросервис:
- Работает в отдельном процессе
- Имеет свою базу данных (или схему)
- Может быть разработан на разном языке/стеке
- Деплоится независимо
- Владеет своим бизнес-доменом

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   User      │     │   Order     │     │  Payment    │
│  Service    │────▶│  Service    │────▶│  Service    │
│             │     │             │     │             │
│  Postgres   │     │   MySQL     │     │   Postgres  │
└─────────────┘     └─────────────┘     └─────────────┘
```

### 2. Bounded Context (ограниченный контекст)

Каждый сервис отвечает за один бизнес-домен:

```go
// User Service - управление пользователями
type UserService struct {
    db *sql.DB
}

func (s *UserService) CreateUser(user *User) error { /* ... */ }
func (s *UserService) GetUser(id int) (*User, error) { /* ... */ }

// Order Service - управление заказами
type OrderService struct {
    db         *sql.DB
    userClient *UserServiceClient // Взаимодействие через API
}

func (s *OrderService) CreateOrder(order *Order) error {
    // Проверяем пользователя через API User Service
    user, err := s.userClient.GetUser(order.UserID)
    if err != nil {
        return err
    }
    // Создаем заказ в своей БД
    return s.db.Exec("INSERT INTO orders ...")
}
```

### 3. Децентрализация

**Децентрализованное управление данными:**
- Каждый сервис владеет своими данными
- Нет общей БД (no shared database)

**Децентрализованное управление:**
- Каждая команда управляет своими сервисами
- Независимые решения по технологиям

### 4. Отказоустойчивость

Сервисы должны уметь работать при сбоях других сервисов:

```go
// Circuit Breaker паттерн
type OrderService struct {
    userClient *UserServiceClient
    breaker    *CircuitBreaker
}

func (s *OrderService) CreateOrder(order *Order) error {
    // Проверяем пользователя с circuit breaker
    user, err := s.breaker.Call(func() (interface{}, error) {
        return s.userClient.GetUser(order.UserID)
    })

    if err != nil {
        // User Service недоступен - используем fallback
        log.Warn("User service unavailable, using cached data")
        // Проверяем в локальном кэше или позволяем создать заказ
        return s.createOrderWithoutUserCheck(order)
    }

    return s.createOrderWithUser(order, user.(*User))
}
```

## Взаимодействие между сервисами

### 1. Синхронное взаимодействие (HTTP/gRPC)

**REST API:**

```go
// User Service - HTTP API
func main() {
    http.HandleFunc("/users/{id}", getUserHandler)
    http.ListenAndServe(":8080", nil)
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    id := mux.Vars(r)["id"]
    user, err := userService.GetUser(id)
    if err != nil {
        http.Error(w, err.Error(), http.StatusNotFound)
        return
    }
    json.NewEncoder(w).Encode(user)
}

// Order Service - HTTP Client
type UserServiceClient struct {
    baseURL string
    client  *http.Client
}

func (c *UserServiceClient) GetUser(id int) (*User, error) {
    url := fmt.Sprintf("%s/users/%d", c.baseURL, id)
    resp, err := c.client.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    return &user, nil
}
```

**gRPC (более эффективно):**

```protobuf
// user.proto
syntax = "proto3";

service UserService {
    rpc GetUser(GetUserRequest) returns (User);
}

message GetUserRequest {
    int32 id = 1;
}

message User {
    int32 id = 1;
    string name = 2;
    string email = 3;
}
```

```go
// User Service - gRPC Server
type userServer struct {
    pb.UnimplementedUserServiceServer
    db *sql.DB
}

func (s *userServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    var user pb.User
    err := s.db.QueryRow("SELECT id, name, email FROM users WHERE id = $1", req.Id).
        Scan(&user.Id, &user.Name, &user.Email)
    return &user, err
}

// Order Service - gRPC Client
conn, _ := grpc.Dial("user-service:50051", grpc.WithInsecure())
client := pb.NewUserServiceClient(conn)

user, err := client.GetUser(ctx, &pb.GetUserRequest{Id: 123})
```

### 2. Асинхронное взаимодействие (Message Queue)

**Через RabbitMQ/Kafka:**

```go
// Order Service - публикует событие "order.created"
type OrderService struct {
    rabbitmq *amqp.Connection
}

func (s *OrderService) CreateOrder(order *Order) error {
    // Сохраняем заказ в БД
    err := s.db.Exec("INSERT INTO orders ...")
    if err != nil {
        return err
    }

    // Публикуем событие
    event := OrderCreatedEvent{
        OrderID:   order.ID,
        UserID:    order.UserID,
        Amount:    order.Amount,
        CreatedAt: time.Now(),
    }

    data, _ := json.Marshal(event)
    ch, _ := s.rabbitmq.Channel()
    return ch.Publish(
        "orders",           // exchange
        "order.created",    // routing key
        false,
        false,
        amqp.Publishing{
            ContentType: "application/json",
            Body:        data,
        },
    )
}

// Email Service - слушает событие "order.created"
type EmailService struct {
    rabbitmq *amqp.Connection
}

func (s *EmailService) Start() {
    ch, _ := s.rabbitmq.Channel()
    msgs, _ := ch.Consume(
        "email-queue",  // queue
        "",
        true,
        false,
        false,
        false,
        nil,
    )

    for msg := range msgs {
        var event OrderCreatedEvent
        json.Unmarshal(msg.Body, &event)

        // Отправляем email
        s.sendOrderConfirmationEmail(event)
    }
}
```

## Service Discovery

Как сервисы находят друг друга?

### 1. Хардкод (не рекомендуется)

```go
// Плохо - хардкод адреса
userClient := NewUserClient("http://user-service.prod.company.com:8080")
```

### 2. Environment Variables

```go
// Лучше - через переменные окружения
userServiceURL := os.Getenv("USER_SERVICE_URL")
userClient := NewUserClient(userServiceURL)
```

```yaml
# docker-compose.yml
services:
  order-service:
    environment:
      USER_SERVICE_URL: "http://user-service:8080"
```

### 3. Service Registry (Consul, etcd)

```go
// Service Registration (User Service регистрируется)
import "github.com/hashicorp/consul/api"

func registerService() {
    client, _ := api.NewClient(api.DefaultConfig())

    registration := &api.AgentServiceRegistration{
        ID:      "user-service-1",
        Name:    "user-service",
        Port:    8080,
        Address: "192.168.1.100",
        Check: &api.AgentServiceCheck{
            HTTP:     "http://192.168.1.100:8080/health",
            Interval: "10s",
        },
    }

    client.Agent().ServiceRegister(registration)
}

// Service Discovery (Order Service ищет User Service)
func discoverUserService() (string, error) {
    client, _ := api.NewClient(api.DefaultConfig())

    services, _, err := client.Health().Service("user-service", "", true, nil)
    if err != nil || len(services) == 0 {
        return "", errors.New("user-service not found")
    }

    // Берем первый здоровый инстанс
    service := services[0]
    return fmt.Sprintf("http://%s:%d", service.Service.Address, service.Service.Port), nil
}
```

### 4. Kubernetes Service Discovery

```go
// В Kubernetes сервисы доступны по DNS
// Формат: <service-name>.<namespace>.svc.cluster.local

userServiceURL := "http://user-service.default.svc.cluster.local:8080"
userClient := NewUserClient(userServiceURL)
```

## API Gateway

API Gateway — единая точка входа для всех клиентских запросов.

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│   API Gateway   │ ◄─── Аутентификация, Rate Limiting, Routing
└────────┬────────┘
         │
    ┌────┴────┬────────┬────────┐
    ▼         ▼        ▼        ▼
┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐
│ User   │ │ Order  │ │Payment │ │ Email  │
│Service │ │Service │ │Service │ │Service │
└────────┘ └────────┘ └────────┘ └────────┘
```

**Реализация на Go:**

```go
// API Gateway
package main

import (
    "net/http"
    "net/http/httputil"
    "net/url"
)

type APIGateway struct {
    userServiceURL    *url.URL
    orderServiceURL   *url.URL
    paymentServiceURL *url.URL
}

func (gw *APIGateway) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // Аутентификация
    token := r.Header.Get("Authorization")
    if !gw.authenticate(token) {
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }

    // Rate Limiting
    if !gw.checkRateLimit(r) {
        http.Error(w, "Too Many Requests", http.StatusTooManyRequests)
        return
    }

    // Routing
    switch {
    case strings.HasPrefix(r.URL.Path, "/users"):
        gw.proxyTo(gw.userServiceURL, w, r)
    case strings.HasPrefix(r.URL.Path, "/orders"):
        gw.proxyTo(gw.orderServiceURL, w, r)
    case strings.HasPrefix(r.URL.Path, "/payments"):
        gw.proxyTo(gw.paymentServiceURL, w, r)
    default:
        http.Error(w, "Not Found", http.StatusNotFound)
    }
}

func (gw *APIGateway) proxyTo(target *url.URL, w http.ResponseWriter, r *http.Request) {
    proxy := httputil.NewSingleHostReverseProxy(target)
    proxy.ServeHTTP(w, r)
}
```

## Паттерны микросервисов

### 1. Database per Service

Каждый сервис имеет свою БД:

```go
// User Service
type UserService struct {
    postgres *sql.DB // Своя БД
}

// Order Service
type OrderService struct {
    mysql *sql.DB // Своя БД (может быть другая СУБД)
}

// ❌ НЕ ДЕЛАЙТЕ ТАК:
// Два сервиса НЕ должны обращаться к одной БД напрямую
```

### 2. Saga Pattern (распределенные транзакции)

Когда операция затрагивает несколько сервисов:

```go
// Создание заказа (Saga)
func (s *OrderService) CreateOrder(order *Order) error {
    // 1. Резервируем товар (Inventory Service)
    err := s.inventoryClient.ReserveProduct(order.ProductID, order.Quantity)
    if err != nil {
        return err
    }

    // 2. Проводим оплату (Payment Service)
    err = s.paymentClient.Charge(order.UserID, order.Amount)
    if err != nil {
        // Откатываем резервацию
        s.inventoryClient.CancelReservation(order.ProductID, order.Quantity)
        return err
    }

    // 3. Создаем заказ
    err = s.db.Exec("INSERT INTO orders ...")
    if err != nil {
        // Откатываем оплату и резервацию
        s.paymentClient.Refund(order.UserID, order.Amount)
        s.inventoryClient.CancelReservation(order.ProductID, order.Quantity)
        return err
    }

    return nil
}
```

**Choreography-based Saga (через события):**

```go
// Order Service публикует событие
func (s *OrderService) CreateOrder(order *Order) error {
    // Создаем заказ в статусе "pending"
    order.Status = "pending"
    s.db.Exec("INSERT INTO orders ...")

    // Публикуем событие
    s.publisher.Publish("order.created", order)
    return nil
}

// Inventory Service слушает и резервирует товар
func (s *InventoryService) onOrderCreated(order *Order) {
    err := s.ReserveProduct(order.ProductID, order.Quantity)
    if err != nil {
        s.publisher.Publish("order.inventory_failed", order)
    } else {
        s.publisher.Publish("order.inventory_reserved", order)
    }
}

// Payment Service слушает и проводит оплату
func (s *PaymentService) onInventoryReserved(order *Order) {
    err := s.Charge(order.UserID, order.Amount)
    if err != nil {
        s.publisher.Publish("order.payment_failed", order)
    } else {
        s.publisher.Publish("order.payment_completed", order)
    }
}

// Order Service обновляет статус
func (s *OrderService) onPaymentCompleted(order *Order) {
    s.db.Exec("UPDATE orders SET status = 'completed' WHERE id = ?", order.ID)
}
```

### 3. Circuit Breaker

Защита от каскадных сбоев:

```go
import "github.com/sony/gobreaker"

type OrderService struct {
    userServiceBreaker *gobreaker.CircuitBreaker
}

func NewOrderService() *OrderService {
    settings := gobreaker.Settings{
        Name:        "user-service",
        MaxRequests: 3,
        Interval:    time.Minute,
        Timeout:     30 * time.Second,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            // Открываем circuit если 5+ ошибок
            return counts.ConsecutiveFailures > 5
        },
    }

    return &OrderService{
        userServiceBreaker: gobreaker.NewCircuitBreaker(settings),
    }
}

func (s *OrderService) GetUserInfo(userID int) (*User, error) {
    result, err := s.userServiceBreaker.Execute(func() (interface{}, error) {
        return s.userClient.GetUser(userID)
    })

    if err != nil {
        // Circuit открыт или запрос failed
        log.Error("User service unavailable", err)
        return nil, err
    }

    return result.(*User), nil
}
```

### 4. Event Sourcing

Хранение событий вместо состояния:

```go
// Events
type OrderEvent struct {
    Type      string
    OrderID   int
    Timestamp time.Time
    Data      json.RawMessage
}

type OrderCreated struct {
    UserID int
    Amount float64
}

type OrderPaid struct {
    PaymentID string
}

type OrderShipped struct {
    TrackingNumber string
}

// Event Store
type EventStore struct {
    db *sql.DB
}

func (es *EventStore) AppendEvent(event OrderEvent) error {
    _, err := es.db.Exec(`
        INSERT INTO events (order_id, type, data, timestamp)
        VALUES ($1, $2, $3, $4)
    `, event.OrderID, event.Type, event.Data, event.Timestamp)
    return err
}

func (es *EventStore) GetEvents(orderID int) ([]OrderEvent, error) {
    rows, _ := es.db.Query(`
        SELECT type, data, timestamp FROM events
        WHERE order_id = $1
        ORDER BY timestamp ASC
    `, orderID)
    defer rows.Close()

    var events []OrderEvent
    for rows.Next() {
        var event OrderEvent
        rows.Scan(&event.Type, &event.Data, &event.Timestamp)
        events = append(events, event)
    }
    return events, nil
}

// Восстановление состояния из событий
func (s *OrderService) GetOrderState(orderID int) (*Order, error) {
    events, err := s.eventStore.GetEvents(orderID)
    if err != nil {
        return nil, err
    }

    order := &Order{ID: orderID}
    for _, event := range events {
        switch event.Type {
        case "order.created":
            var data OrderCreated
            json.Unmarshal(event.Data, &data)
            order.UserID = data.UserID
            order.Amount = data.Amount
            order.Status = "created"
        case "order.paid":
            order.Status = "paid"
        case "order.shipped":
            var data OrderShipped
            json.Unmarshal(event.Data, &data)
            order.TrackingNumber = data.TrackingNumber
            order.Status = "shipped"
        }
    }

    return order, nil
}
```

## Мониторинг и observability

### 1. Distributed Tracing (Jaeger/Zipkin)

```go
import (
    "github.com/opentracing/opentracing-go"
    "github.com/uber/jaeger-client-go"
)

// Инициализация трейсинга
func initTracing() {
    cfg := &config.Configuration{
        ServiceName: "order-service",
        Sampler: &config.SamplerConfig{
            Type:  "const",
            Param: 1,
        },
        Reporter: &config.ReporterConfig{
            LogSpans:           true,
            LocalAgentHostPort: "jaeger:6831",
        },
    }

    tracer, _, _ := cfg.NewTracer()
    opentracing.SetGlobalTracer(tracer)
}

// Использование
func (s *OrderService) CreateOrder(ctx context.Context, order *Order) error {
    span, ctx := opentracing.StartSpanFromContext(ctx, "create_order")
    defer span.Finish()

    // Вызов другого сервиса - автоматически передается trace ID
    user, err := s.userClient.GetUser(ctx, order.UserID)
    if err != nil {
        span.SetTag("error", true)
        return err
    }

    return s.db.Insert(ctx, order)
}
```

### 2. Метрики (Prometheus)

```go
import "github.com/prometheus/client_golang/prometheus"

var (
    ordersCreated = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "orders_created_total",
            Help: "Total number of orders created",
        },
        []string{"status"},
    )

    orderDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "order_creation_duration_seconds",
            Help:    "Order creation duration",
            Buckets: prometheus.DefBuckets,
        },
        []string{"status"},
    )
)

func init() {
    prometheus.MustRegister(ordersCreated)
    prometheus.MustRegister(orderDuration)
}

func (s *OrderService) CreateOrder(order *Order) error {
    start := time.Now()

    err := s.createOrderInternal(order)

    duration := time.Since(start).Seconds()
    if err != nil {
        ordersCreated.WithLabelValues("error").Inc()
        orderDuration.WithLabelValues("error").Observe(duration)
        return err
    }

    ordersCreated.WithLabelValues("success").Inc()
    orderDuration.WithLabelValues("success").Observe(duration)
    return nil
}
```

### 3. Health Checks

```go
func healthCheckHandler(w http.ResponseWriter, r *http.Request) {
    health := struct {
        Status   string            `json:"status"`
        Services map[string]string `json:"services"`
    }{
        Status:   "ok",
        Services: make(map[string]string),
    }

    // Проверяем БД
    if err := db.Ping(); err != nil {
        health.Status = "degraded"
        health.Services["database"] = "down"
    } else {
        health.Services["database"] = "up"
    }

    // Проверяем зависимые сервисы
    if err := userServiceClient.Ping(); err != nil {
        health.Status = "degraded"
        health.Services["user-service"] = "down"
    } else {
        health.Services["user-service"] = "up"
    }

    statusCode := http.StatusOK
    if health.Status != "ok" {
        statusCode = http.StatusServiceUnavailable
    }

    w.WriteHeader(statusCode)
    json.NewEncoder(w).Encode(health)
}
```

## Deployment

### Docker Compose (локальная разработка)

```yaml
version: '3.8'

services:
  user-service:
    build: ./user-service
    ports:
      - "8081:8080"
    environment:
      DATABASE_URL: "postgres://postgres:password@postgres:5432/users"
    depends_on:
      - postgres

  order-service:
    build: ./order-service
    ports:
      - "8082:8080"
    environment:
      DATABASE_URL: "mysql://root:password@mysql:3306/orders"
      USER_SERVICE_URL: "http://user-service:8080"
    depends_on:
      - mysql
      - user-service

  postgres:
    image: postgres:14
    environment:
      POSTGRES_PASSWORD: password

  mysql:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: password
```

### Kubernetes (продакшн)

```yaml
# user-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: myregistry/user-service:v1.0
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: postgres-url
---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - port: 8080
    targetPort: 8080
```

## Преимущества и недостатки

### ✅ Преимущества

1. **Независимое развертывание** - можно обновлять сервисы независимо
2. **Масштабируемость** - масштабируем только нужные сервисы
3. **Технологическое разнообразие** - разные языки для разных сервисов
4. **Отказоустойчивость** - сбой одного сервиса не роняет всю систему
5. **Команды** - небольшие автономные команды

### ❌ Недостатки

1. **Сложность** - больше движущихся частей
2. **Распределенные транзакции** - сложнее обеспечить ACID
3. **Сетевые задержки** - межсервисное взаимодействие медленнее
4. **Тестирование** - сложнее тестировать интеграции
5. **Operational overhead** - больше сервисов для мониторинга и деплоя

## Best Practices

1. ✅ **Start with monolith** - начинайте с монолита, переходите к микросервисам при необходимости
2. ✅ **One service = one team** - сервис должен поддерживаться одной командой
3. ✅ **Database per service** - каждый сервис имеет свою БД
4. ✅ **API versioning** - версионируйте API (/v1/, /v2/)
5. ✅ **Idempotency** - операции должны быть идемпотентными
6. ✅ **Circuit breakers** - защита от каскадных сбоев
7. ✅ **Distributed tracing** - обязательно для отладки
8. ✅ **Health checks** - мониторинг состояния сервисов
9. ❌ **Избегайте nano-services** - слишком мелкие сервисы = оверхед
10. ❌ **Не делите по технологии** - делите по бизнес-доменам

## Когда использовать микросервисы

**✅ Используйте когда:**
- Большая команда (> 10-20 разработчиков)
- Высокая нагрузка с разными паттернами (нужно масштабировать части системы)
- Разные домены с четкими границами
- Нужна независимая deployability

**❌ Не используйте когда:**
- Малая команда (< 5 разработчиков)
- Простое приложение (CRUD)
- Стартап (неизвестны границы доменов)
- Нет опыта с распределенными системами

## Связанные темы

- [[Монолит vs Микросервисы]]
- [[REST API - Основы]]
- [[gRPC]]
- [[RabbitMQ]]
- [[Apache Kafka]]
- [[Service Mesh]]
- [[Docker - Основы]]
- [[Kubernetes - Основы]]
- [[CAP теорема]]
- [[PostgreSQL - ACID]]
