# Задача - Переворот связного списка

Классическая задача на работу с указателями и связными списками.

## Условие

Дан односвязный список. Необходимо развернуть его (reverse).

```
Input:  1 → 2 → 3 → 4 → 5 → nil
Output: 5 → 4 → 3 → 2 → 1 → nil
```

**Требования:**
- Решить in-place (без создания нового списка)
- O(n) время
- O(1) дополнительная память

## Определение структуры

```go
type ListNode struct {
    Val  int
    Next *ListNode
}
```

## Подход 1: Итеративный (Рекомендуется)

**Идея:** Переворачиваем указатели по ходу движения.

```
Было:    1 → 2 → 3 → nil
         ↑
       prev

Итерация 1:
nil ← 1   2 → 3 → nil
      ↑   ↑
    prev curr

Итерация 2:
nil ← 1 ← 2   3 → nil
          ↑   ↑
        prev curr

Итерация 3:
nil ← 1 ← 2 ← 3
              ↑
            prev (new head)
```

### Решение

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode  // nil
    curr := head

    for curr != nil {
        // Сохранить следующий узел
        next := curr.Next

        // Развернуть указатель
        curr.Next = prev

        // Сдвинуть указатели
        prev = curr
        curr = next
    }

    return prev  // Новая голова
}
```

**Сложность:**
- Время: O(n) - один проход
- Память: O(1) - только 3 указателя

### Пошаговый пример

```go
// Начальный список: 1 → 2 → 3 → nil
head = &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3}}}

// Итерация 1:
// prev = nil, curr = 1, next = 2
// 1.Next = nil (разворот)
// prev = 1, curr = 2

// Итерация 2:
// prev = 1, curr = 2, next = 3
// 2.Next = 1 (разворот)
// prev = 2, curr = 3

// Итерация 3:
// prev = 2, curr = 3, next = nil
// 3.Next = 2 (разворот)
// prev = 3, curr = nil

// Возвращаем prev (3) - новая голова
// Результат: 3 → 2 → 1 → nil
```

## Подход 2: Рекурсивный

**Идея:** Рекурсивно дойти до конца, затем переворачивать на обратном пути.

```go
func reverseListRecursive(head *ListNode) *ListNode {
    // Базовый случай
    if head == nil || head.Next == nil {
        return head
    }

    // Рекурсивно развернуть остаток
    newHead := reverseListRecursive(head.Next)

    // Развернуть текущий узел
    head.Next.Next = head
    head.Next = nil

    return newHead
}
```

**Визуализация рекурсии:**

```
reverseList(1)
  reverseList(2)
    reverseList(3)
      reverseList(4)
        reverseList(5) → return 5
      ↓ 4.Next.Next = 4 (5 → 4)
      return 5
    ↓ 3.Next.Next = 3 (4 → 3)
    return 5
  ↓ 2.Next.Next = 2 (3 → 2)
  return 5
↓ 1.Next.Next = 1 (2 → 1)
return 5

Результат: 5 → 4 → 3 → 2 → 1 → nil
```

**Сложность:**
- Время: O(n)
- Память: O(n) - стек рекурсии

## Вариация: Переворот части списка

Развернуть список от позиции `left` до `right`.

```
Input:  1 → 2 → 3 → 4 → 5 → nil, left = 2, right = 4
Output: 1 → 4 → 3 → 2 → 5 → nil
```

### Решение

```go
func reverseBetween(head *ListNode, left, right int) *ListNode {
    if head == nil || left == right {
        return head
    }

    dummy := &ListNode{Next: head}
    prev := dummy

    // Дойти до позиции left-1
    for i := 1; i < left; i++ {
        prev = prev.Next
    }

    // Развернуть подсписок [left, right]
    curr := prev.Next
    for i := 0; i < right-left; i++ {
        next := curr.Next
        curr.Next = next.Next
        next.Next = prev.Next
        prev.Next = next
    }

    return dummy.Next
}
```

## Распространённые ошибки

### Ошибка 1: Потеря ссылки на Next

```go
// ❌ Неправильно
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head

    for curr != nil {
        curr.Next = prev  // Потеряли ссылку на next!
        prev = curr
        curr = curr.Next  // curr.Next уже = prev!
    }

    return prev
}
```

**Почему:** После `curr.Next = prev` мы потеряли оригинальный `Next`.

**Правильно:**

```go
// ✅ Правильно
next := curr.Next  // Сохранить перед изменением
curr.Next = prev
prev = curr
curr = next  // Использовать сохранённое значение
```

### Ошибка 2: Забыли обнулить last.Next

```go
// ❌ Неправильно
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head

    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }

    // Если не обнулили head.Next, получим цикл!
    // head.Next всё ещё указывает на второй элемент

    return prev
}
```

В итеративной версии это решается автоматически, так как `prev` начинается с `nil`. Но в рекурсивной нужно явно обнулять:

```go
head.Next = nil  // ✅ Важно!
```

## Вопрос с собеседования (VK Tech, Яндекс)

**Вопрос:** Как развернуть список, не меняя значения Val, а только переставляя указатели?

**Ответ:** Именно это и делает итеративное решение! Мы не трогаем `.Val`, а только меняем `.Next`.

**Вопрос:** Почему рекурсивное решение использует O(n) память?

**Ответ:** Каждый рекурсивный вызов добавляет фрейм в стек. Для списка длины n будет n фреймов на стеке.

**Вопрос:** Можно ли развернуть список за O(1) память и O(log n) время?

**Ответ:** Нет. Необходимо посетить каждый узел хотя бы один раз, поэтому минимум O(n) времени.

## Связанные задачи

### Проверка на палиндром

```go
func isPalindrome(head *ListNode) bool {
    // Найти середину (fast/slow pointers)
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    // Развернуть вторую половину
    secondHalf := reverseList(slow)

    // Сравнить две половины
    p1, p2 := head, secondHalf
    for p2 != nil {
        if p1.Val != p2.Val {
            return false
        }
        p1 = p1.Next
        p2 = p2.Next
    }

    return true
}
```

### Переворот K-групп

```go
// Развернуть список группами по k узлов
// 1 → 2 → 3 → 4 → 5, k = 2
// 2 → 1 → 4 → 3 → 5

func reverseKGroup(head *ListNode, k int) *ListNode {
    dummy := &ListNode{Next: head}
    prev := dummy

    for {
        // Проверить, есть ли k узлов
        kth := getKth(prev, k)
        if kth == nil {
            break
        }

        // Развернуть группу
        next := kth.Next
        curr := prev.Next

        for i := 0; i < k-1; i++ {
            tmp := curr.Next
            curr.Next = tmp.Next
            tmp.Next = prev.Next
            prev.Next = tmp
        }

        prev = curr
        prev.Next = next
    }

    return dummy.Next
}

func getKth(curr *ListNode, k int) *ListNode {
    for curr != nil && k > 0 {
        curr = curr.Next
        k--
    }
    return curr
}
```

## Визуальная помощь

```
Переворот указателей:

Before:
  1 → 2 → 3
  ↑
head

After:
  3 → 2 → 1
  ↑
head

Итеративный процесс:
prev = nil, curr = 1
  nil   1 → 2 → 3
        ↑
      curr

Step 1: next = 2, 1.Next = nil, prev = 1, curr = 2
  nil ← 1   2 → 3
        ↑   ↑
      prev curr

Step 2: next = 3, 2.Next = 1, prev = 2, curr = 3
  nil ← 1 ← 2   3
            ↑   ↑
          prev curr

Step 3: next = nil, 3.Next = 2, prev = 3, curr = nil
  nil ← 1 ← 2 ← 3
                ↑
              prev (return)
```

## Тестовые случаи

```go
func main() {
    // Тест 1: Обычный список
    head := &ListNode{1, &ListNode{2, &ListNode{3, &ListNode{4, &ListNode{5, nil}}}}}
    reversed := reverseList(head)
    // 5 → 4 → 3 → 2 → 1 → nil

    // Тест 2: Пустой список
    head = nil
    reversed = reverseList(head)  // nil

    // Тест 3: Один элемент
    head = &ListNode{Val: 1}
    reversed = reverseList(head)  // 1 → nil

    // Тест 4: Два элемента
    head = &ListNode{1, &ListNode{2, nil}}
    reversed = reverseList(head)  // 2 → 1 → nil
}
```

## Best Practices

1. ✅ Используйте итеративный подход для production кода (O(1) память)
2. ✅ Сохраняйте `Next` перед изменением указателей
3. ✅ Проверяйте граничные случаи (nil, один элемент)
4. ✅ Dummy node упрощает работу с головой списка
5. ❌ Не забывайте обнулять `last.Next`
6. ❌ Не изменяйте `.Val` (меняем только указатели!)

## Вопросы на собеседовании

**VK Tech:**
"Как развернуть односвязный список in-place за O(1) память?"

**Яндекс:**
"Чем отличается итеративный и рекурсивный подход? Какой лучше и почему?"

**Озон:**
"Как развернуть только часть списка от позиции L до R?"

**T-Bank:**
"Как проверить, является ли список палиндромом, используя переворот?"

## Связанные темы

- [[Связные списки]]
- [[Go - Указатели и ссылки]]
- [[Два указателя (Two Pointers)]]
- [[Go - Указатели - Подводные камни]]
- [[Алгоритмическая сложность (Big O)]]
