# Динамическое программирование - Основы

DP (Dynamic Programming) - оптимизация рекурсии через кэширование подзадач.

## Концепция

**Без DP:**
```
fib(5) = fib(4) + fib(3)
       = (fib(3) + fib(2)) + (fib(2) + fib(1))
       = ...

fib(3) вычисляется дважды! O(2^n)
```

**С DP:**
```
fib(5) = fib(4) + fib(3)
         ↓кэш    ↓из кэша

fib(3) вычисляется один раз! O(n)
```

## Признаки DP задачи

1. **Overlapping Subproblems** - подзадачи повторяются
2. **Optimal Substructure** - оптимум из оптимумов подзадач

**Ключевые слова:**
- "Максимум/минимум"
- "Количество способов"
- "Можно ли..."
- "Longest/Shortest"

## Подходы

### 1. Memoization (Top-Down)

Рекурсия + кэш.

```go
// Fibonacci
func fib(n int) int {
    memo := make(map[int]int)
    return fibMemo(n, memo)
}

func fibMemo(n int, memo map[int]int) int {
    if n <= 1 {
        return n
    }

    if val, ok := memo[n]; ok {
        return val
    }

    memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo)
    return memo[n]
}

// O(n) время, O(n) память
```

### 2. Tabulation (Bottom-Up)

Итеративное заполнение таблицы.

```go
func fib(n int) int {
    if n <= 1 {
        return n
    }

    dp := make([]int, n+1)
    dp[0] = 0
    dp[1] = 1

    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}

// O(n) время, O(n) память
```

### 3. Space Optimization

Храним только необходимое.

```go
func fib(n int) int {
    if n <= 1 {
        return n
    }

    prev2, prev1 := 0, 1

    for i := 2; i <= n; i++ {
        current := prev1 + prev2
        prev2 = prev1
        prev1 = current
    }

    return prev1
}

// O(n) время, O(1) память
```

## Классические задачи

### 1. Climbing Stairs

```go
// Сколько способов подняться на n ступеней (шаги 1 или 2)?
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }

    dp := make([]int, n+1)
    dp[1] = 1
    dp[2] = 2

    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}

// climbStairs(3) → 3 (1+1+1, 1+2, 2+1)
```

### 2. Coin Change

```go
// Минимум монет для суммы amount
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)

    // Инициализация
    for i := 1; i <= amount; i++ {
        dp[i] = amount + 1  // Infinity
    }
    dp[0] = 0

    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if coin <= i {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }

    if dp[amount] > amount {
        return -1
    }

    return dp[amount]
}

// coinChange([1,2,5], 11) → 3 (5+5+1)
```

### 3. Longest Increasing Subsequence (LIS)

```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    dp := make([]int, len(nums))

    // dp[i] = длина LIS заканчивающейся на i
    for i := range dp {
        dp[i] = 1
    }

    maxLen := 1

    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
        maxLen = max(maxLen, dp[i])
    }

    return maxLen
}

// lengthOfLIS([10,9,2,5,3,7,101,18]) → 4 ([2,3,7,101])
// O(n²) время
```

### 4. House Robber

```go
// Максимальная сумма (нельзя грабить соседние дома)
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }

    dp := make([]int, len(nums))
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])

    for i := 2; i < len(nums); i++ {
        // Грабить i или не грабить
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }

    return dp[len(nums)-1]
}

// rob([2,7,9,3,1]) → 12 (2+9+1)
```

**Оптимизация памяти:**

```go
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    prev2, prev1 := 0, 0

    for _, num := range nums {
        current := max(prev1, prev2+num)
        prev2 = prev1
        prev1 = current
    }

    return prev1
}

// O(n) время, O(1) память
```

### 5. Unique Paths

```go
// Количество путей в сетке m×n (только вправо/вниз)
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    // Базовые случаи
    for i := 0; i < m; i++ {
        dp[i][0] = 1
    }
    for j := 0; j < n; j++ {
        dp[0][j] = 1
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }

    return dp[m-1][n-1]
}

// uniquePaths(3, 7) → 28
```

### 6. Edit Distance (Levenshtein)

```go
func minDistance(word1 string, word2 string) int {
    m, n := len(word1), len(word2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    // Базовые случаи
    for i := 0; i <= m; i++ {
        dp[i][0] = i
    }
    for j := 0; j <= n; j++ {
        dp[0][j] = j
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = 1 + min(
                    dp[i-1][j],   // Удалить
                    dp[i][j-1],   // Вставить
                    dp[i-1][j-1], // Заменить
                )
            }
        }
    }

    return dp[m][n]
}

// minDistance("horse", "ros") → 3
```

### 7. Knapsack 0/1

```go
func knapsack(weights []int, values []int, capacity int) int {
    n := len(weights)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }

    for i := 1; i <= n; i++ {
        for w := 1; w <= capacity; w++ {
            if weights[i-1] <= w {
                // Взять или не взять
                dp[i][w] = max(
                    dp[i-1][w],
                    dp[i-1][w-weights[i-1]]+values[i-1],
                )
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }

    return dp[n][capacity]
}
```

## Шаблон DP

```go
func dpProblem(input) result {
    // 1. Определить состояние
    dp := make([]type, size)

    // 2. Базовые случаи
    dp[0] = baseCase

    // 3. Transition formula
    for i := 1; i < size; i++ {
        dp[i] = f(dp[i-1], dp[i-2], ...)
    }

    // 4. Вернуть ответ
    return dp[size-1]
}
```

## Типы DP

### 1D DP

```go
// dp[i] = ответ для i
dp[i] = f(dp[i-1], dp[i-2], ...)
```

### 2D DP

```go
// dp[i][j] = ответ для (i, j)
dp[i][j] = f(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
```

### 3D DP

```go
// dp[i][j][k] = ответ для (i, j, k)
// Редко используется
```

## Сложность

| Подход | Time | Space |
|--------|------|-------|
| Naive Recursion | O(2^n) | O(n) stack |
| Memoization | O(n×k) | O(n×k) |
| Tabulation | O(n×k) | O(n×k) |
| Optimized | O(n×k) | O(k) |

## Шаги решения DP задачи

1. **Определить состояние** - что означает dp[i]?
2. **Найти рекуррентное соотношение** - как вычислить dp[i]?
3. **Базовые случаи** - dp[0], dp[1], ...
4. **Порядок вычисления** - от меньшего к большему
5. **Оптимизация памяти** - нужна ли вся таблица?

## Top-Down vs Bottom-Up

**Top-Down (Memoization):**
- ✅ Проще написать (рекурсия)
- ✅ Вычисляет только нужные состояния
- ❌ Риск stack overflow
- ❌ Overhead рекурсии

**Bottom-Up (Tabulation):**
- ✅ Нет stack overflow
- ✅ Быстрее (нет рекурсии)
- ❌ Вычисляет все состояния
- ❌ Сложнее понять порядок

## Best Practices

1. ✅ Начните с рекурсии + мемоизация
2. ✅ Затем переведите в bottom-up
3. ✅ Оптимизируйте память
4. ✅ Проверьте базовые случаи
5. ✅ Тестируйте на малых примерах
6. ❌ Не оптимизируйте преждевременно
7. ❌ Помните про переполнение (используйте mod)

## Когда НЕ использовать DP

- Жадный алгоритм проще и работает
- Нет overlapping subproblems
- Нет optimal substructure
- Память критична (2D/3D DP)

## Связанные темы

- [[Жадные алгоритмы]]
- [[Рекурсия]]
- [[Алгоритмическая сложность (Big O)]]
- [[Временная и пространственная сложность]]
