# Задача - Climbing Stairs

Базовая задача на динамическое программирование. Числа Фибоначчи в действии.

## Условие

Вы поднимаетесь по лестнице. Нужно `n` шагов, чтобы достичь вершины.

За один раз вы можете подняться на 1 или 2 ступеньки. Сколькими различными способами вы можете подняться на вершину?

**Пример 1:**
```
Вход: n = 2
Выход: 2
Объяснение: Есть два способа подняться на вершину:
1. 1 шаг + 1 шаг
2. 2 шага
```

**Пример 2:**
```
Вход: n = 3
Выход: 3
Объяснение: Есть три способа подняться на вершину:
1. 1 шаг + 1 шаг + 1 шаг
2. 1 шаг + 2 шага
3. 2 шага + 1 шаг
```

**Пример 3:**
```
Вход: n = 4
Выход: 5
Объяснение:
1. 1+1+1+1
2. 1+1+2
3. 1+2+1
4. 2+1+1
5. 2+2
```

## Анализ задачи

**Ключевые наблюдения:**
- Чтобы попасть на ступеньку `n`, можно прийти с ступеньки `n-1` (шаг 1) или `n-2` (шаг 2)
- Количество способов попасть на `n`: `ways(n) = ways(n-1) + ways(n-2)`
- Это формула чисел Фибоначчи!

**Базовые случаи:**
- `n = 1`: 1 способ (один шаг)
- `n = 2`: 2 способа (1+1 или 2)

**Рекуррентное соотношение:**
```
f(n) = f(n-1) + f(n-2)

где:
f(1) = 1
f(2) = 2
```

**Связь с Фибоначчи:**
```
n  | ways | Fibonacci
---|------|----------
1  |  1   | F(2) = 1
2  |  2   | F(3) = 2
3  |  3   | F(4) = 3
4  |  5   | F(5) = 5
5  |  8   | F(6) = 8
```

## Решение 1: Рекурсия (Brute Force)

**Идея:** Прямая реализация рекуррентной формулы.

**Сложность:** O(2ⁿ) по времени, O(n) по памяти (стек рекурсии)

```go
func climbStairsRecursive(n int) int {
    if n <= 2 {
        return n
    }

    return climbStairsRecursive(n-1) + climbStairsRecursive(n-2)
}
```

**Недостатки:**
- ❌ Экспоненциальная сложность
- ❌ Много повторяющихся вычислений
- ❌ Stack overflow для больших n

**Дерево рекурсии для n=5:**
```
                    f(5)
                   /    \
              f(4)        f(3)
             /    \       /   \
         f(3)    f(2)  f(2)  f(1)
        /   \
     f(2)  f(1)

Повторяющиеся вычисления: f(3), f(2), f(1)
```

## Решение 2: Мемоизация (Top-Down DP)

**Идея:** Сохранять результаты подзадач в кеше.

**Сложность:** O(n) по времени, O(n) по памяти

```go
func climbStairsMemo(n int) int {
    memo := make(map[int]int)
    return climbStairsMemoHelper(n, memo)
}

func climbStairsMemoHelper(n int, memo map[int]int) int {
    // Проверяем кеш
    if val, exists := memo[n]; exists {
        return val
    }

    // Базовые случаи
    if n <= 2 {
        return n
    }

    // Вычисляем и кешируем
    result := climbStairsMemoHelper(n-1, memo) + climbStairsMemoHelper(n-2, memo)
    memo[n] = result

    return result
}
```

**Преимущества:**
- ✅ Линейная сложность
- ✅ Каждая подзадача вычисляется один раз

## Решение 3: Итеративный DP (Bottom-Up)

**Идея:** Строить решение снизу вверх, от базовых случаев.

**Сложность:** O(n) по времени, O(n) по памяти

```go
func climbStairsDP(n int) int {
    if n <= 2 {
        return n
    }

    // dp[i] = количество способов достичь ступеньки i
    dp := make([]int, n+1)
    dp[1] = 1
    dp[2] = 2

    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}
```

## Решение 4: Оптимизация памяти (Оптимальное)

**Идея:** Хранить только последние два значения вместо всего массива.

**Сложность:** O(n) по времени, O(1) по памяти ✅

```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }

    // Нужны только два предыдущих значения
    prev2 := 1  // f(1)
    prev1 := 2  // f(2)

    for i := 3; i <= n; i++ {
        current := prev1 + prev2
        prev2 = prev1
        prev1 = current
    }

    return prev1
}
```

**Альтернативная запись с множественным присваиванием:**
```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }

    a, b := 1, 2

    for i := 3; i <= n; i++ {
        a, b = b, a+b
    }

    return b
}
```

## Пошаговое объяснение

Рассмотрим пример: `n = 5`

### Итеративный подход (с массивом)

```
Инициализация:
dp[1] = 1
dp[2] = 2

Итерация i=3:
dp[3] = dp[2] + dp[1] = 2 + 1 = 3

Итерация i=4:
dp[4] = dp[3] + dp[2] = 3 + 2 = 5

Итерация i=5:
dp[5] = dp[4] + dp[3] = 5 + 3 = 8

Ответ: 8 ✅
```

### Оптимизированный подход (без массива)

```
Инициализация:
prev2 = 1, prev1 = 2

Итерация i=3:
current = 2 + 1 = 3
prev2 = 2, prev1 = 3

Итерация i=4:
current = 3 + 2 = 5
prev2 = 3, prev1 = 5

Итерация i=5:
current = 5 + 3 = 8
prev2 = 5, prev1 = 8

Ответ: 8 ✅
```

## Визуализация

```
Лестница из 5 ступенек:

Ступенька | Количество способов | Откуда пришли
----------|--------------------|--------------
    1     |         1          | Стартовая позиция
    2     |         2          | 1 или прыжок на 2
    3     |         3          | 2 (шаг 1) или 1 (шаг 2)
    4     |         5          | 3 (шаг 1) или 2 (шаг 2)
    5     |         8          | 4 (шаг 1) или 3 (шаг 2)

Формула: ways[n] = ways[n-1] + ways[n-2]
```

### Все способы для n=4

```
1. [1, 1, 1, 1]
2. [1, 1, 2]
3. [1, 2, 1]
4. [2, 1, 1]
5. [2, 2]

Всего: 5 способов ✅
```

## Тестовые случаи

```go
func TestClimbStairs(t *testing.T) {
    tests := []struct {
        n        int
        expected int
    }{
        {1, 1},
        {2, 2},
        {3, 3},
        {4, 5},
        {5, 8},
        {6, 13},
        {10, 89},
        {20, 10946},
    }

    for _, tt := range tests {
        result := climbStairs(tt.n)
        if result != tt.expected {
            t.Errorf("climbStairs(%d) = %d, expected %d",
                tt.n, result, tt.expected)
        }
    }
}
```

## Полное решение

```go
package main

import "fmt"

// Оптимальное решение: O(n) время, O(1) память
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }

    prev2, prev1 := 1, 2

    for i := 3; i <= n; i++ {
        current := prev1 + prev2
        prev2 = prev1
        prev1 = current
    }

    return prev1
}

// Решение с мемоизацией
func climbStairsMemo(n int) int {
    memo := make(map[int]int)
    return helper(n, memo)
}

func helper(n int, memo map[int]int) int {
    if val, exists := memo[n]; exists {
        return val
    }

    if n <= 2 {
        return n
    }

    result := helper(n-1, memo) + helper(n-2, memo)
    memo[n] = result
    return result
}

func main() {
    for n := 1; n <= 10; n++ {
        ways := climbStairs(n)
        fmt.Printf("n=%2d: %d способов\n", n, ways)
    }
}
```

## Решение 5: Формула Бине (математическое)

**Идея:** Использовать формулу для n-го числа Фибоначчи.

**Формула:**
```
F(n) = (φⁿ - ψⁿ) / √5

где:
φ = (1 + √5) / 2 ≈ 1.618 (золотое сечение)
ψ = (1 - √5) / 2 ≈ -0.618
```

**Сложность:** O(1) по времени, O(1) по памяти

```go
import "math"

func climbStairsMath(n int) int {
    sqrt5 := math.Sqrt(5)
    phi := (1 + sqrt5) / 2
    psi := (1 - sqrt5) / 2

    // Сдвиг на 1, так как наша последовательность начинается с F(2)
    return int(math.Round((math.Pow(phi, float64(n+1)) - math.Pow(psi, float64(n+1))) / sqrt5))
}
```

**Недостатки:**
- ❌ Проблемы с точностью для больших n
- ❌ Менее понятно, чем итеративное решение

## Вариации задачи

### 1. Можно делать шаги 1, 2 или 3

```go
func climbStairsThreeSteps(n int) int {
    if n == 0 {
        return 1
    }
    if n < 0 {
        return 0
    }

    dp := make([]int, n+1)
    dp[0] = 1
    dp[1] = 1
    if n >= 2 {
        dp[2] = 2
    }

    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
    }

    return dp[n]
}
```

### 2. Минимальная стоимость подъема

Каждая ступенька имеет стоимость `cost[i]`:

```go
func minCostClimbingStairs(cost []int) int {
    n := len(cost)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return cost[0]
    }

    dp := make([]int, n)
    dp[0] = cost[0]
    dp[1] = cost[1]

    for i := 2; i < n; i++ {
        dp[i] = cost[i] + min(dp[i-1], dp[i-2])
    }

    // Можем финишировать на n-1 или n-2
    return min(dp[n-1], dp[n-2])
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 3. С препятствиями

Некоторые ступеньки заблокированы:

```go
func climbStairsWithObstacles(n int, obstacles map[int]bool) int {
    if n <= 0 {
        return 0
    }

    dp := make([]int, n+1)
    dp[0] = 1

    for i := 1; i <= n; i++ {
        if obstacles[i] {
            dp[i] = 0  // Заблокирована
            continue
        }

        dp[i] = dp[i-1]
        if i >= 2 {
            dp[i] += dp[i-2]
        }
    }

    return dp[n]
}
```

## Где спрашивают

- **LeetCode:** #70 - Climbing Stairs
- **LeetCode:** #746 - Min Cost Climbing Stairs
- **Яндекс:** Базовая задача на DP, часто для разминки
- **Авито:** Могут усложнить условие
- **Т-Банк:** Просят оптимизировать память
- **Озон:** Классическое введение в DP

## Вопросы с собеседований

**Вопрос 1:** Почему это задача на динамическое программирование?

**Ответ:** Есть оптимальная подструктура (решение для n зависит от n-1 и n-2) и перекрывающиеся подзадачи (одни и те же значения вычисляются многократно в наивной рекурсии).

---

**Вопрос 2:** Можно ли улучшить сложность по памяти?

**Ответ:** Да, вместо массива хранить только два последних значения, получая O(1) памяти.

---

**Вопрос 3:** Как изменится решение для шагов 1, 2, 3, ..., k?

**Ответ:** `dp[i] = sum(dp[i-1], dp[i-2], ..., dp[i-k])` для i >= k. Нужно хранить последние k значений.

---

**Вопрос 4:** Связь с числами Фибоначчи?

**Ответ:** Последовательность решений - это числа Фибоначчи со сдвигом: ways(n) = Fib(n+1).

## Best Practices

1. ✅ Используйте итеративный подход с O(1) памятью
2. ✅ Проверяйте базовые случаи (n=1, n=2)
3. ✅ Для больших n используйте int64 или big.Int
4. ✅ Рекурсию используйте только с мемоизацией
5. ❌ Не используйте чистую рекурсию для n > 20
6. ❌ Не забывайте про переполнение для больших n

## Применение в реальности

### Комбинаторные задачи

```go
// Количество способов составить сумму из монет номиналом 1 и 2
func coinChange(amount int) int {
    return climbStairs(amount)
}
```

### Планирование задач

```go
// Количество способов выполнить n задач,
// где можно выполнять 1 или 2 задачи за раз
type TaskScheduler struct {
    totalTasks int
}

func (ts *TaskScheduler) CountWays() int {
    return climbStairs(ts.totalTasks)
}
```

### Генерация последовательностей

```go
// Количество бинарных строк длины n без двух последовательных единиц
func countBinaryStrings(n int) int {
    // Это также последовательность Фибоначчи
    return climbStairs(n)
}
```

## Связанные темы

- [[Динамическое программирование - Основы]]
- [[Алгоритмическая сложность (Big O)]]
- [[Go - Карты (maps)]]
- [[Go - Массивы и слайсы]]
