# Бинарный поиск

Эффективный алгоритм поиска в **отсортированном** массиве за O(log n).

## Принцип работы

Делим массив пополам, отбрасываем половину где элемента точно нет.

```
Найти 7 в [1, 3, 5, 7, 9, 11, 13]

Шаг 1: mid=7, target=7 → Найден!

Найти 9:
Шаг 1: mid=7 < 9  → ищем в [9, 11, 13]
Шаг 2: mid=11 > 9 → ищем в [9]
Шаг 3: mid=9 = 9  → Найден!
```

## Базовая реализация

```go
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1

    for left <= right {
        mid := left + (right-left)/2  // Избегаем overflow

        if arr[mid] == target {
            return mid  // Найден
        }

        if arr[mid] < target {
            left = mid + 1  // Ищем в правой половине
        } else {
            right = mid - 1  // Ищем в левой половине
        }
    }

    return -1  // Не найден
}

// binarySearch([1,3,5,7,9], 7) → 3
// binarySearch([1,3,5,7,9], 6) → -1
```

**Почему `mid = left + (right-left)/2`?**

```go
// ❌ Overflow для больших массивов
mid := (left + right) / 2  // left+right может переполниться

// ✅ Безопасно
mid := left + (right-left)/2
```

## Рекурсивная версия

```go
func binarySearchRecursive(arr []int, target, left, right int) int {
    if left > right {
        return -1
    }

    mid := left + (right-left)/2

    if arr[mid] == target {
        return mid
    }

    if arr[mid] < target {
        return binarySearchRecursive(arr, target, mid+1, right)
    }

    return binarySearchRecursive(arr, target, left, mid-1)
}

// Использование
result := binarySearchRecursive(arr, target, 0, len(arr)-1)
```

## Варианты задач

### Найти первое вхождение

```go
func findFirst(arr []int, target int) int {
    left, right := 0, len(arr)-1
    result := -1

    for left <= right {
        mid := left + (right-left)/2

        if arr[mid] == target {
            result = mid       // Запоминаем
            right = mid - 1    // Ищем левее
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return result
}

// findFirst([1,2,2,2,3], 2) → 1 (первый индекс)
```

### Найти последнее вхождение

```go
func findLast(arr []int, target int) int {
    left, right := 0, len(arr)-1
    result := -1

    for left <= right {
        mid := left + (right-left)/2

        if arr[mid] == target {
            result = mid      // Запоминаем
            left = mid + 1    // Ищем правее
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return result
}

// findLast([1,2,2,2,3], 2) → 3 (последний индекс)
```

### Количество вхождений

```go
func countOccurrences(arr []int, target int) int {
    first := findFirst(arr, target)
    if first == -1 {
        return 0
    }

    last := findLast(arr, target)
    return last - first + 1
}

// countOccurrences([1,2,2,2,3], 2) → 3
```

## Поиск точки вставки

```go
// Найти индекс куда вставить target, чтобы сохранить порядок
func searchInsert(arr []int, target int) int {
    left, right := 0, len(arr)-1

    for left <= right {
        mid := left + (right-left)/2

        if arr[mid] == target {
            return mid
        }

        if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return left  // Точка вставки
}

// searchInsert([1,3,5,6], 5) → 2
// searchInsert([1,3,5,6], 2) → 1
// searchInsert([1,3,5,6], 7) → 4
```

## Lower Bound и Upper Bound

### Lower Bound (первый ≥ target)

```go
func lowerBound(arr []int, target int) int {
    left, right := 0, len(arr)

    for left < right {
        mid := left + (right-left)/2

        if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid
        }
    }

    return left
}

// lowerBound([1,2,2,2,3], 2) → 1 (первый ≥ 2)
// lowerBound([1,2,2,2,3], 0) → 0
```

### Upper Bound (первый > target)

```go
func upperBound(arr []int, target int) int {
    left, right := 0, len(arr)

    for left < right {
        mid := left + (right-left)/2

        if arr[mid] <= target {
            left = mid + 1
        } else {
            right = mid
        }
    }

    return left
}

// upperBound([1,2,2,2,3], 2) → 4 (первый > 2)
```

## Бинарный поиск по ответу

### Найти квадратный корень

```go
func sqrt(x int) int {
    if x == 0 {
        return 0
    }

    left, right := 1, x
    result := 0

    for left <= right {
        mid := left + (right-left)/2

        if mid <= x/mid {  // Избегаем overflow
            result = mid
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return result
}

// sqrt(8) → 2 (2² = 4 ≤ 8 < 3² = 9)
```

### Найти пик в массиве

```go
func findPeakElement(nums []int) int {
    left, right := 0, len(nums)-1

    for left < right {
        mid := left + (right-left)/2

        if nums[mid] < nums[mid+1] {
            left = mid + 1  // Пик справа
        } else {
            right = mid     // Пик слева или mid
        }
    }

    return left
}

// findPeakElement([1,2,3,1]) → 2 (элемент 3)
// findPeakElement([1,2,1,3,5,6,4]) → 5 (элемент 6)
```

### Минимум в ротированном массиве

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1

    for left < right {
        mid := left + (right-left)/2

        if nums[mid] > nums[right] {
            left = mid + 1  // Минимум справа
        } else {
            right = mid     // Минимум слева или mid
        }
    }

    return nums[left]
}

// findMin([3,4,5,1,2]) → 1
// findMin([4,5,6,7,0,1,2]) → 0
```

### Поиск в ротированном массиве

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1

    for left <= right {
        mid := left + (right-left)/2

        if nums[mid] == target {
            return mid
        }

        // Определить отсортированную половину
        if nums[left] <= nums[mid] {
            // Левая половина отсортирована
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            // Правая половина отсортирована
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }

    return -1
}

// search([4,5,6,7,0,1,2], 0) → 4
// search([4,5,6,7,0,1,2], 3) → -1
```

## Бинарный поиск для решения задач

### Koko Eating Bananas (LeetCode 875)

```go
func minEatingSpeed(piles []int, h int) int {
    left, right := 1, maxPile(piles)

    for left < right {
        mid := left + (right-left)/2

        if canEatAll(piles, mid, h) {
            right = mid  // Попробовать меньше
        } else {
            left = mid + 1
        }
    }

    return left
}

func canEatAll(piles []int, speed, hours int) bool {
    time := 0
    for _, pile := range piles {
        time += (pile + speed - 1) / speed  // Округление вверх
    }
    return time <= hours
}

func maxPile(piles []int) int {
    max := 0
    for _, pile := range piles {
        if pile > max {
            max = pile
        }
    }
    return max
}
```

### Capacity To Ship Packages (LeetCode 1011)

```go
func shipWithinDays(weights []int, days int) int {
    left, right := maxWeight(weights), sumWeights(weights)

    for left < right {
        mid := left + (right-left)/2

        if canShip(weights, mid, days) {
            right = mid
        } else {
            left = mid + 1
        }
    }

    return left
}

func canShip(weights []int, capacity, days int) bool {
    currentDay := 1
    currentWeight := 0

    for _, weight := range weights {
        if currentWeight+weight > capacity {
            currentDay++
            currentWeight = 0
        }
        currentWeight += weight
    }

    return currentDay <= days
}
```

## Go sort.Search

Стандартная библиотека:

```go
import "sort"

// Найти первый индекс где arr[i] >= target
arr := []int{1, 2, 2, 2, 3, 5, 8}
target := 2

index := sort.Search(len(arr), func(i int) bool {
    return arr[i] >= target
})

if index < len(arr) && arr[index] == target {
    fmt.Println("Найдено на индексе:", index)
} else {
    fmt.Println("Не найдено")
}

// Поиск точки вставки
index := sort.SearchInts(arr, target)
```

## Сложность

| Операция | Сложность |
|----------|-----------|
| Поиск | O(log n) |
| Worst case | O(log n) |
| Best case | O(1) |
| Space | O(1) |

## Требования

**Обязательно:**
- Массив должен быть **отсортирован**
- Для модифицированных задач: монотонная функция

## Шаблон бинарного поиска

```go
// Общий шаблон
func binarySearch(left, right int, condition func(int) bool) int {
    for left < right {
        mid := left + (right-left)/2

        if condition(mid) {
            right = mid      // Или left = mid + 1
        } else {
            left = mid + 1   // Или right = mid - 1
        }
    }

    return left  // Или right
}
```

**Выбор границ:**
- `left <= right` и `left = mid + 1, right = mid - 1` → может вернуть -1
- `left < right` и `left = mid + 1, right = mid` → всегда возвращает индекс

## Best Practices

1. ✅ Всегда проверяйте что массив отсортирован
2. ✅ Используйте `mid = left + (right-left)/2`
3. ✅ Тщательно выбирайте условия (`<`, `<=`, `>=`, `>`)
4. ✅ Проверяйте граничные случаи (пустой массив, один элемент)
5. ✅ sort.Search для стандартных случаев
6. ❌ Не забывайте про `left < right` vs `left <= right`
7. ❌ Не используйте для несортированных данных

## Связанные темы

- [[Сортировки - Быстрая, слиянием, пузырьком]]
- [[Алгоритмическая сложность (Big O)]]
- [[Деревья - Основы]]
- [[Heap (куча)]]
