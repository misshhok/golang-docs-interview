# Связные списки

Динамическая структура данных из узлов, связанных указателями.

## Типы связных списков

### Односвязный список (Singly Linked List)

```go
type Node struct {
    Value int
    Next  *Node
}

type LinkedList struct {
    Head *Node
    Size int
}
```

Каждый узел содержит:
- Данные (Value)
- Указатель на следующий узел (Next)

### Двусвязный список (Doubly Linked List)

```go
type DoublyNode struct {
    Value int
    Next  *DoublyNode
    Prev  *DoublyNode
}

type DoublyLinkedList struct {
    Head *DoublyNode
    Tail *DoublyNode
    Size int
}
```

Каждый узел содержит:
- Данные
- Указатель на следующий узел
- Указатель на предыдущий узел

### Циклический список (Circular Linked List)

Последний узел указывает на первый.

## Операции

### Вставка в начало

```go
func (ll *LinkedList) InsertFront(value int) {
    newNode := &Node{Value: value, Next: ll.Head}
    ll.Head = newNode
    ll.Size++
}

// Сложность: O(1)
```

### Вставка в конец

```go
func (ll *LinkedList) InsertBack(value int) {
    newNode := &Node{Value: value}

    if ll.Head == nil {
        ll.Head = newNode
        ll.Size++
        return
    }

    // Найти последний узел
    current := ll.Head
    for current.Next != nil {
        current = current.Next
    }
    current.Next = newNode
    ll.Size++
}

// Сложность: O(n) - нужно пройти до конца
```

**Оптимизация:** хранить указатель на Tail

```go
type LinkedList struct {
    Head *Node
    Tail *Node
    Size int
}

func (ll *LinkedList) InsertBack(value int) {
    newNode := &Node{Value: value}

    if ll.Head == nil {
        ll.Head = newNode
        ll.Tail = newNode
    } else {
        ll.Tail.Next = newNode
        ll.Tail = newNode
    }
    ll.Size++
}

// Сложность: O(1)
```

### Вставка в середину

```go
func (ll *LinkedList) InsertAt(index, value int) error {
    if index < 0 || index > ll.Size {
        return errors.New("index out of bounds")
    }

    if index == 0 {
        ll.InsertFront(value)
        return nil
    }

    current := ll.Head
    for i := 0; i < index-1; i++ {
        current = current.Next
    }

    newNode := &Node{Value: value, Next: current.Next}
    current.Next = newNode
    ll.Size++
    return nil
}

// Сложность: O(n)
```

### Удаление из начала

```go
func (ll *LinkedList) DeleteFront() error {
    if ll.Head == nil {
        return errors.New("list is empty")
    }

    ll.Head = ll.Head.Next
    ll.Size--
    return nil
}

// Сложность: O(1)
```

### Удаление из конца

```go
func (ll *LinkedList) DeleteBack() error {
    if ll.Head == nil {
        return errors.New("list is empty")
    }

    if ll.Head.Next == nil {
        ll.Head = nil
        ll.Size--
        return nil
    }

    // Найти предпоследний узел
    current := ll.Head
    for current.Next.Next != nil {
        current = current.Next
    }
    current.Next = nil
    ll.Size--
    return nil
}

// Сложность: O(n)
```

### Поиск

```go
func (ll *LinkedList) Find(value int) *Node {
    current := ll.Head
    for current != nil {
        if current.Value == value {
            return current
        }
        current = current.Next
    }
    return nil
}

// Сложность: O(n)
```

### Получение по индексу

```go
func (ll *LinkedList) Get(index int) (int, error) {
    if index < 0 || index >= ll.Size {
        return 0, errors.New("index out of bounds")
    }

    current := ll.Head
    for i := 0; i < index; i++ {
        current = current.Next
    }
    return current.Value, nil
}

// Сложность: O(n)
```

## Переворот списка

```go
func (ll *LinkedList) Reverse() {
    var prev *Node
    current := ll.Head

    for current != nil {
        next := current.Next  // Сохраняем next
        current.Next = prev   // Разворачиваем указатель
        prev = current        // Сдвигаем prev
        current = next        // Сдвигаем current
    }

    ll.Head = prev
}

// Сложность: O(n)
// Память: O(1)
```

Подробнее: [[Задача - Переворот связного списка]]

## Обнаружение цикла

### Floyd's Cycle Detection (Черепаха и Заяц)

```go
func (ll *LinkedList) HasCycle() bool {
    if ll.Head == nil {
        return false
    }

    slow := ll.Head  // Черепаха (1 шаг)
    fast := ll.Head  // Заяц (2 шага)

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            return true  // Цикл найден
        }
    }

    return false
}

// Сложность: O(n)
// Память: O(1)
```

## Найти середину списка

```go
func (ll *LinkedList) FindMiddle() *Node {
    if ll.Head == nil {
        return nil
    }

    slow := ll.Head
    fast := ll.Head

    for fast.Next != nil && fast.Next.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    return slow
}

// Сложность: O(n)
// Память: O(1)
```

## Сложность операций

| Операция | Односвязный | Двусвязный | Массив/Slice |
|----------|-------------|------------|--------------|
| Вставка в начало | O(1) | O(1) | O(n) |
| Вставка в конец | O(1)* | O(1) | O(1)† |
| Вставка в середину | O(n) | O(n) | O(n) |
| Удаление из начала | O(1) | O(1) | O(n) |
| Удаление из конца | O(n) | O(1) | O(1) |
| Поиск | O(n) | O(n) | O(n) |
| Доступ по индексу | O(n) | O(n) | O(1) |

\* С указателем на Tail
† Амортизированное

## Двусвязный список

### Вставка в конец

```go
func (dll *DoublyLinkedList) InsertBack(value int) {
    newNode := &DoublyNode{Value: value}

    if dll.Head == nil {
        dll.Head = newNode
        dll.Tail = newNode
    } else {
        dll.Tail.Next = newNode
        newNode.Prev = dll.Tail
        dll.Tail = newNode
    }
    dll.Size++
}

// Сложность: O(1)
```

### Удаление из конца

```go
func (dll *DoublyLinkedList) DeleteBack() error {
    if dll.Tail == nil {
        return errors.New("list is empty")
    }

    if dll.Head == dll.Tail {
        dll.Head = nil
        dll.Tail = nil
    } else {
        dll.Tail = dll.Tail.Prev
        dll.Tail.Next = nil
    }
    dll.Size--
    return nil
}

// Сложность: O(1)
```

## Списки vs Массивы

### Преимущества списков

✅ Динамический размер
✅ Вставка/удаление из начала - O(1)
✅ Нет перевыделения памяти
✅ Легко разделить/объединить

### Недостатки списков

❌ Нет прямого доступа по индексу
❌ Дополнительная память на указатели
❌ Плохая cache locality
❌ Нельзя использовать бинарный поиск

### Когда использовать

**Используйте список когда:**
- Частые вставки/удаления из начала
- Неизвестный размер
- Не нужен доступ по индексу

**Используйте массив/slice когда:**
- Нужен быстрый доступ по индексу
- Итерация важнее вставки
- Известен размер
- Важна cache locality

## Реализация container/list в Go

```go
import "container/list"

// Создать список
l := list.New()

// Вставка
l.PushBack(1)
l.PushFront(2)

// Итерация
for e := l.Front(); e != nil; e = e.Next() {
    fmt.Println(e.Value)
}

// Удаление
element := l.Front()
l.Remove(element)
```

## Практические примеры

### LRU Cache

```go
type LRUCache struct {
    capacity int
    cache    map[int]*list.Element
    list     *list.List
}

type entry struct {
    key   int
    value int
}

func (c *LRUCache) Get(key int) int {
    if elem, ok := c.cache[key]; ok {
        c.list.MoveToFront(elem)  // Recently used
        return elem.Value.(*entry).value
    }
    return -1
}
```

Подробнее: [[Задача - LRU Cache]]

### Очередь на списке

```go
type Queue struct {
    list *LinkedList
}

func (q *Queue) Enqueue(value int) {
    q.list.InsertBack(value)  // O(1) с Tail
}

func (q *Queue) Dequeue() (int, error) {
    if q.list.Size == 0 {
        return 0, errors.New("queue is empty")
    }
    value, _ := q.list.Get(0)
    q.list.DeleteFront()
    return value, nil
}
```

## Best Practices

1. ✅ Используйте container/list вместо своей реализации
2. ✅ Храните указатель на Tail для O(1) вставки в конец
3. ✅ Рассмотрите slice вместо списка (cache locality)
4. ✅ Двусвязный список для двунаправленной итерации
5. ❌ Не используйте для случайного доступа
6. ❌ Не забывайте обновлять Size

## Связанные темы

- [[Стек и очередь]]
- [[Задача - Переворот связного списка]]
- [[Задача - LRU Cache]]
- [[Временная и пространственная сложность]]
